import { __awaiter } from 'tslib';
import { execSync } from 'child_process';
import path from 'path';
import { __dirname } from './loadEnv.js';
import setupLogger from '../middleware/logger.js';
function decryptFile(encryptedFilePath) {
	return __awaiter(this, void 0, void 0, function* () {
		let logger = yield setupLogger();
		try {
			let decryptedFile = execSync(
				`sops -d --output-type json ${encryptedFilePath}`
			).toString();
			return decryptedFile;
		} catch (err) {
			logger.error('Error decrypting file from SOPS: ', err);
			throw err;
		}
	});
}
function decryptDataFiles() {
	return __awaiter(this, void 0, void 0, function* () {
		let logger = yield setupLogger();
		try {
			let filePaths = [
				process.env.SERVER_DATA_FILE_PATH_1,
				process.env.SERVER_DATA_FILE_PATH_2,
				process.env.SERVER_DATA_FILE_PATH_3,
				process.env.SERVER_DATA_FILE_PATH_4
			];
			let decryptedFiles = {};
			for (let [index, filePath] of filePaths.entries()) {
				if (filePath) {
					decryptedFiles[`files${index + 1}`] = execSync(
						`sops -d --output-type json ${filePath}`
					).toString();
				} else {
					logger.warn(
						`SERVER_DATA_FILE_PATH_${index + 1} is not defined`
					);
				}
			}
			return decryptedFiles;
		} catch (err) {
			logger.error(
				'Error decrypting files from backend data folder: ',
				err
			);
			throw err;
		}
	});
}
function getSSLKeys() {
	return __awaiter(this, void 0, void 0, function* () {
		let logger = yield setupLogger();
		try {
			let keyPath = path.join(
				__dirname,
				'./keys/ssl/guestbook_key.pem.gpg'
			);
			let certPath = path.join(
				__dirname,
				'./keys/ssl/guestbook_cert.pem.gpg'
			);
			let decryptedKey = yield decryptFile(keyPath);
			let decryptedCert = yield decryptFile(certPath);
			return {
				key: decryptedKey,
				cert: decryptedCert
			};
		} catch (err) {
			logger.error('Error retrieving SSL keys from SOPS: ', err);
			throw err;
		}
	});
}
export default { decryptDataFiles, getSSLKeys };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29wcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3RzL2NvbmZpZy9zb3BzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3RDLE9BQU8sV0FBVyxNQUFNLHNCQUFzQixDQUFDO0FBRS9DLFNBQWUsV0FBVyxDQUFDLGlCQUF5Qjs7UUFDbkQsSUFBSSxNQUFNLEdBQUcsTUFBTSxXQUFXLEVBQUUsQ0FBQztRQUVqQyxJQUFJLENBQUM7WUFDSixJQUFJLGFBQWEsR0FBRyxRQUFRLENBQzNCLDhCQUE4QixpQkFBaUIsRUFBRSxDQUNqRCxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2IsT0FBTyxhQUFhLENBQUM7UUFDdEIsQ0FBQztRQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFDZCxNQUFNLENBQUMsS0FBSyxDQUFDLG1DQUFtQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZELE1BQU0sR0FBRyxDQUFDO1FBQ1gsQ0FBQztJQUNGLENBQUM7Q0FBQTtBQUVELFNBQWUsZ0JBQWdCOztRQUM5QixJQUFJLE1BQU0sR0FBRyxNQUFNLFdBQVcsRUFBRSxDQUFDO1FBRWpDLElBQUksQ0FBQztZQUNKLElBQUksU0FBUyxHQUFHO2dCQUNmLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCO2dCQUNuQyxPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QjtnQkFDbkMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUI7Z0JBQ25DLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCO2FBQ25DLENBQUM7WUFFRixJQUFJLGNBQWMsR0FBOEIsRUFBRSxDQUFDO1lBRW5ELEtBQUssSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsSUFBSSxTQUFTLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztnQkFDbkQsSUFBSSxRQUFRLEVBQUUsQ0FBQztvQkFDZCxjQUFjLENBQUMsUUFBUSxLQUFLLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQzdDLDhCQUE4QixRQUFRLEVBQUUsQ0FDeEMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDZCxDQUFDO3FCQUFNLENBQUM7b0JBQ1AsTUFBTSxDQUFDLElBQUksQ0FDVix5QkFBeUIsS0FBSyxHQUFHLENBQUMsaUJBQWlCLENBQ25ELENBQUM7Z0JBQ0gsQ0FBQztZQUNGLENBQUM7WUFFRCxPQUFPLGNBQWMsQ0FBQztRQUN2QixDQUFDO1FBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztZQUNkLE1BQU0sQ0FBQyxLQUFLLENBQUMsbURBQW1ELEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdkUsTUFBTSxHQUFHLENBQUM7UUFDWCxDQUFDO0lBQ0YsQ0FBQztDQUFBO0FBRUQsU0FBZSxVQUFVOztRQUN4QixJQUFJLE1BQU0sR0FBRyxNQUFNLFdBQVcsRUFBRSxDQUFDO1FBRWpDLElBQUksQ0FBQztZQUNKLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGtDQUFrQyxDQUFDLENBQUM7WUFDdkUsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FDdkIsU0FBUyxFQUNULG1DQUFtQyxDQUNuQyxDQUFDO1lBQ0YsSUFBSSxZQUFZLEdBQUcsTUFBTSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDOUMsSUFBSSxhQUFhLEdBQUcsTUFBTSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFaEQsT0FBTztnQkFDTixHQUFHLEVBQUUsWUFBWTtnQkFDakIsSUFBSSxFQUFFLGFBQWE7YUFDbkIsQ0FBQztRQUNILENBQUM7UUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2QsTUFBTSxDQUFDLEtBQUssQ0FBQyx1Q0FBdUMsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUMzRCxNQUFNLEdBQUcsQ0FBQztRQUNYLENBQUM7SUFDRixDQUFDO0NBQUE7QUFFRCxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBfX2Rpcm5hbWUgfSBmcm9tICcuL2xvYWRFbnYnO1xuaW1wb3J0IHNldHVwTG9nZ2VyIGZyb20gJy4uL21pZGRsZXdhcmUvbG9nZ2VyJztcblxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdEZpbGUoZW5jcnlwdGVkRmlsZVBhdGg6IHN0cmluZykge1xuXHRsZXQgbG9nZ2VyID0gYXdhaXQgc2V0dXBMb2dnZXIoKTtcblxuXHR0cnkge1xuXHRcdGxldCBkZWNyeXB0ZWRGaWxlID0gZXhlY1N5bmMoXG5cdFx0XHRgc29wcyAtZCAtLW91dHB1dC10eXBlIGpzb24gJHtlbmNyeXB0ZWRGaWxlUGF0aH1gXG5cdFx0KS50b1N0cmluZygpO1xuXHRcdHJldHVybiBkZWNyeXB0ZWRGaWxlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRsb2dnZXIuZXJyb3IoJ0Vycm9yIGRlY3J5cHRpbmcgZmlsZSBmcm9tIFNPUFM6ICcsIGVycik7XG5cdFx0dGhyb3cgZXJyO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHREYXRhRmlsZXMoKSB7XG5cdGxldCBsb2dnZXIgPSBhd2FpdCBzZXR1cExvZ2dlcigpO1xuXG5cdHRyeSB7XG5cdFx0bGV0IGZpbGVQYXRocyA9IFtcblx0XHRcdHByb2Nlc3MuZW52LlNFUlZFUl9EQVRBX0ZJTEVfUEFUSF8xLFxuXHRcdFx0cHJvY2Vzcy5lbnYuU0VSVkVSX0RBVEFfRklMRV9QQVRIXzIsXG5cdFx0XHRwcm9jZXNzLmVudi5TRVJWRVJfREFUQV9GSUxFX1BBVEhfMyxcblx0XHRcdHByb2Nlc3MuZW52LlNFUlZFUl9EQVRBX0ZJTEVfUEFUSF80XG5cdFx0XTtcblxuXHRcdGxldCBkZWNyeXB0ZWRGaWxlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgW2luZGV4LCBmaWxlUGF0aF0gb2YgZmlsZVBhdGhzLmVudHJpZXMoKSkge1xuXHRcdFx0aWYgKGZpbGVQYXRoKSB7XG5cdFx0XHRcdGRlY3J5cHRlZEZpbGVzW2BmaWxlcyR7aW5kZXggKyAxfWBdID0gZXhlY1N5bmMoXG5cdFx0XHRcdFx0YHNvcHMgLWQgLS1vdXRwdXQtdHlwZSBqc29uICR7ZmlsZVBhdGh9YFxuXHRcdFx0XHQpLnRvU3RyaW5nKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2dnZXIud2Fybihcblx0XHRcdFx0XHRgU0VSVkVSX0RBVEFfRklMRV9QQVRIXyR7aW5kZXggKyAxfSBpcyBub3QgZGVmaW5lZGBcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVjcnlwdGVkRmlsZXM7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGxvZ2dlci5lcnJvcignRXJyb3IgZGVjcnlwdGluZyBmaWxlcyBmcm9tIGJhY2tlbmQgZGF0YSBmb2xkZXI6ICcsIGVycik7XG5cdFx0dGhyb3cgZXJyO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFNTTEtleXMoKSB7XG5cdGxldCBsb2dnZXIgPSBhd2FpdCBzZXR1cExvZ2dlcigpO1xuXG5cdHRyeSB7XG5cdFx0bGV0IGtleVBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi9rZXlzL3NzbC9ndWVzdGJvb2tfa2V5LnBlbS5ncGcnKTtcblx0XHRsZXQgY2VydFBhdGggPSBwYXRoLmpvaW4oXG5cdFx0XHRfX2Rpcm5hbWUsXG5cdFx0XHQnLi9rZXlzL3NzbC9ndWVzdGJvb2tfY2VydC5wZW0uZ3BnJ1xuXHRcdCk7XG5cdFx0bGV0IGRlY3J5cHRlZEtleSA9IGF3YWl0IGRlY3J5cHRGaWxlKGtleVBhdGgpO1xuXHRcdGxldCBkZWNyeXB0ZWRDZXJ0ID0gYXdhaXQgZGVjcnlwdEZpbGUoY2VydFBhdGgpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGtleTogZGVjcnlwdGVkS2V5LFxuXHRcdFx0Y2VydDogZGVjcnlwdGVkQ2VydFxuXHRcdH07XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGxvZ2dlci5lcnJvcignRXJyb3IgcmV0cmlldmluZyBTU0wga2V5cyBmcm9tIFNPUFM6ICcsIGVycik7XG5cdFx0dGhyb3cgZXJyO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgZGVjcnlwdERhdGFGaWxlcywgZ2V0U1NMS2V5cyB9O1xuIl19
