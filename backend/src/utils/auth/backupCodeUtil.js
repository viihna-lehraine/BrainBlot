import { __awaiter } from 'tslib';
import bcrypt from 'bcrypt';
import crypto from 'crypto';
import setupLogger from '../../middleware/logger.js';
import UserMfaModelPromise from '../../models/UserMfa.js';
// Generate Backup Coedes
function generateBackupCodes(id) {
	return __awaiter(this, void 0, void 0, function* () {
		let backupCodes = [];
		for (let i = 0; i < 16; i++) {
			let code = crypto.randomBytes(4).toString('hex'); // 8-character hex code
			let hashedCode = yield bcrypt.hash(code, 10);
			backupCodes.push({ code: hashedCode, used: false });
		}
		// store backupCodes in the database associated with the user's id
		yield saveBackupCodesToDatabase(id, backupCodes);
		// return only the plain codes as strings
		return backupCodes.map((backupCode) => backupCode.code);
	});
}
// Verify a Backup Code
function verifyBackupCode(id, inputCode) {
	return __awaiter(this, void 0, void 0, function* () {
		yield UserMfaModelPromise; // await the UserMfa model when needed
		let storedCodes = yield getBackupCodesFromDatabase(id);
		if (storedCodes) {
			for (let i = 0; i < storedCodes.length; i++) {
				let match = yield bcrypt.compare(
					inputCode,
					storedCodes[i].code
				);
				if (match && !storedCodes[i].used) {
					storedCodes[i].used = true;
					yield updateBackupCodesInDatabase(id, storedCodes); // mark the code as used
					return true; // successful verification
				}
			}
		} else {
			console.error('No backup codes found for user');
			return false; // no backup codes found
		}
		return false; // verification failed
	});
}
// Save backup codes to the database
function saveBackupCodesToDatabase(id, backupCodes) {
	return __awaiter(this, void 0, void 0, function* () {
		let logger = yield setupLogger();
		let UserfMfa = yield UserMfaModelPromise; // await the UserMfa model when needed
		try {
			let user = yield UserfMfa.findByPk(id); // find user by primary key
			if (!user) throw new Error('User not found');
			// map the codes element of backupCodes to an array of strings
			let backupCodesAsStrings = backupCodes.map(
				(codeObj) => codeObj.code
			);
			// assign the array of strings to user.backupCodes
			user.backupCodes = backupCodesAsStrings;
			yield user.save();
		} catch (err) {
			logger.error('Error saving backup codes to database: ', err);
			throw new Error('Failed to save backup codes to database');
		}
	});
}
// Get backup codes from the database
function getBackupCodesFromDatabase(id) {
	return __awaiter(this, void 0, void 0, function* () {
		let logger = yield setupLogger();
		let UserMfa = yield UserMfaModelPromise; // await the User model when needed
		try {
			let user = yield UserMfa.findByPk(id); // find user by primary key
			if (!user) throw new Error('User not found');
			// assume user.backupCodes is a string[] or null, convert it to BackuopCode[] or undefined
			let backupCodes = user.backupCodes;
			if (backupCodes === null) {
				return undefined; // *DEV-NOTE* probably need to configure this later
			}
			// convert string[] to BackupCode[]
			return backupCodes.map((code) => ({ code, used: false }));
		} catch (err) {
			logger.error('Error fetching backup codes from database: ', err);
			throw new Error('Failed to retrieve backup codes from database');
		}
	});
}
// Update backup codes in the database
function updateBackupCodesInDatabase(id, backupCodes) {
	return __awaiter(this, void 0, void 0, function* () {
		let logger = yield setupLogger();
		let UserMfa = yield UserMfaModelPromise; // await the UserMfa model when needed
		try {
			let user = yield UserMfa.findByPk(id); // find user by primary key
			if (!user) throw new Error('User not found');
			// map the codes element of backupCodes to an array of strings
			let backupCodesAsStrings = backupCodes.map(
				(codeObj) => codeObj.code
			);
			// assign the array of strings to user.backupCodes
			user.backupCodes = backupCodesAsStrings;
			yield user.save();
		} catch (err) {
			logger.error('Error updating backup codes in database: ', err);
			throw new Error('Failed to update backup codes in database');
		}
	});
}
export {
	generateBackupCodes,
	getBackupCodesFromDatabase,
	saveBackupCodesToDatabase,
	verifyBackupCode
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja3VwQ29kZVV0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi90cy91dGlscy9hdXRoL2JhY2t1cENvZGVVdGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sV0FBVyxNQUFNLHlCQUF5QixDQUFDO0FBQ2xELE9BQU8sbUJBQW1CLE1BQU0sc0JBQXNCLENBQUM7QUFPdkQseUJBQXlCO0FBQ3pCLFNBQWUsbUJBQW1CLENBQUMsRUFBVTs7UUFDNUMsSUFBSSxXQUFXLEdBQWlCLEVBQUUsQ0FBQztRQUNuQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyx1QkFBdUI7WUFDekUsSUFBSSxVQUFVLEdBQUcsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM3QyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNyRCxDQUFDO1FBRUQsa0VBQWtFO1FBQ2xFLE1BQU0seUJBQXlCLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBRWpELHlDQUF5QztRQUN6QyxPQUFPLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6RCxDQUFDO0NBQUE7QUFFRCx1QkFBdUI7QUFDdkIsU0FBZSxnQkFBZ0IsQ0FDOUIsRUFBVSxFQUNWLFNBQWlCOztRQUVqQixN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MEJBQTBCLEVBQzFCLHlCQUF5QixFQUN6QixnQkFBZ0IsRUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiY3J5cHQgZnJvbSAnYmNyeXB0JztcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCBzZXR1cExvZ2dlciBmcm9tICcuLi8uLi9taWRkbGV3YXJlL2xvZ2dlcic7XG5pbXBvcnQgVXNlck1mYU1vZGVsUHJvbWlzZSBmcm9tICcuLi8uLi9tb2RlbHMvVXNlck1mYSc7XG5cbmludGVyZmFjZSBCYWNrdXBDb2RlIHtcblx0Y29kZTogc3RyaW5nO1xuXHR1c2VkOiBib29sZWFuO1xufVxuXG4vLyBHZW5lcmF0ZSBCYWNrdXAgQ29lZGVzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUJhY2t1cENvZGVzKGlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG5cdGxldCBiYWNrdXBDb2RlczogQmFja3VwQ29kZVtdID0gW107XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHRcdGxldCBjb2RlID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnRvU3RyaW5nKCdoZXgnKTsgLy8gOC1jaGFyYWN0ZXIgaGV4IGNvZGVcblx0XHRsZXQgaGFzaGVkQ29kZSA9IGF3YWl0IGJjcnlwdC5oYXNoKGNvZGUsIDEwKTtcblx0XHRiYWNrdXBDb2Rlcy5wdXNoKHsgY29kZTogaGFzaGVkQ29kZSwgdXNlZDogZmFsc2UgfSk7XG5cdH1cblxuXHQvLyBzdG9yZSBiYWNrdXBDb2RlcyBpbiB0aGUgZGF0YWJhc2UgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyJ3MgaWRcblx0YXdhaXQgc2F2ZUJhY2t1cENvZGVzVG9EYXRhYmFzZShpZCwgYmFja3VwQ29kZXMpO1xuXG5cdC8vIHJldHVybiBvbmx5IHRoZSBwbGFpbiBjb2RlcyBhcyBzdHJpbmdzXG5cdHJldHVybiBiYWNrdXBDb2Rlcy5tYXAoKGJhY2t1cENvZGUpID0+IGJhY2t1cENvZGUuY29kZSk7XG59XG5cbi8vIFZlcmlmeSBhIEJhY2t1cCBDb2RlXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlCYWNrdXBDb2RlKFxuXHRpZDogc3RyaW5nLFxuXHRpbnB1dENvZGU6IHN0cmluZ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdGF3YWl0IFVzZXJNZmFNb2RlbFByb21pc2U7IC8vIGF3YWl0IHRoZSBVc2VyTWZhIG1vZGVsIHdoZW4gbmVlZGVkXG5cdGxldCBzdG9yZWRDb2RlcyA9IGF3YWl0IGdldEJhY2t1cENvZGVzRnJvbURhdGFiYXNlKGlkKTtcblxuXHRpZiAoc3RvcmVkQ29kZXMpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JlZENvZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgbWF0Y2ggPSBhd2FpdCBiY3J5cHQuY29tcGFyZShpbnB1dENvZGUsIHN0b3JlZENvZGVzW2ldLmNvZGUpO1xuXHRcdFx0aWYgKG1hdGNoICYmICFzdG9yZWRDb2Rlc1tpXS51c2VkKSB7XG5cdFx0XHRcdHN0b3JlZENvZGVzW2ldLnVzZWQgPSB0cnVlO1xuXHRcdFx0XHRhd2FpdCB1cGRhdGVCYWNrdXBDb2Rlc0luRGF0YWJhc2UoaWQsIHN0b3JlZENvZGVzKTsgLy8gbWFyayB0aGUgY29kZSBhcyB1c2VkXG5cdFx0XHRcdHJldHVybiB0cnVlOyAvLyBzdWNjZXNzZnVsIHZlcmlmaWNhdGlvblxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLmVycm9yKCdObyBiYWNrdXAgY29kZXMgZm91bmQgZm9yIHVzZXInKTtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vIGJhY2t1cCBjb2RlcyBmb3VuZFxuXHR9XG5cblx0cmV0dXJuIGZhbHNlOyAvLyB2ZXJpZmljYXRpb24gZmFpbGVkXG59XG5cbi8vIFNhdmUgYmFja3VwIGNvZGVzIHRvIHRoZSBkYXRhYmFzZVxuYXN5bmMgZnVuY3Rpb24gc2F2ZUJhY2t1cENvZGVzVG9EYXRhYmFzZShcblx0aWQ6IHN0cmluZyxcblx0YmFja3VwQ29kZXM6IEJhY2t1cENvZGVbXVxuKTogUHJvbWlzZTx2b2lkPiB7XG5cdGxldCBsb2dnZXIgPSBhd2FpdCBzZXR1cExvZ2dlcigpO1xuXHRsZXQgVXNlcmZNZmEgPSBhd2FpdCBVc2VyTWZhTW9kZWxQcm9taXNlOyAvLyBhd2FpdCB0aGUgVXNlck1mYSBtb2RlbCB3aGVuIG5lZWRlZFxuXG5cdHRyeSB7XG5cdFx0bGV0IHVzZXIgPSBhd2FpdCBVc2VyZk1mYS5maW5kQnlQayhpZCk7IC8vIGZpbmQgdXNlciBieSBwcmltYXJ5IGtleVxuXHRcdGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpO1xuXG5cdFx0Ly8gbWFwIHRoZSBjb2RlcyBlbGVtZW50IG9mIGJhY2t1cENvZGVzIHRvIGFuIGFycmF5IG9mIHN0cmluZ3Ncblx0XHRsZXQgYmFja3VwQ29kZXNBc1N0cmluZ3MgPSBiYWNrdXBDb2Rlcy5tYXAoKGNvZGVPYmopID0+IGNvZGVPYmouY29kZSk7XG5cblx0XHQvLyBhc3NpZ24gdGhlIGFycmF5IG9mIHN0cmluZ3MgdG8gdXNlci5iYWNrdXBDb2Rlc1xuXHRcdHVzZXIuYmFja3VwQ29kZXMgPSBiYWNrdXBDb2Rlc0FzU3RyaW5ncztcblx0XHRhd2FpdCB1c2VyLnNhdmUoKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0bG9nZ2VyLmVycm9yKCdFcnJvciBzYXZpbmcgYmFja3VwIGNvZGVzIHRvIGRhdGFiYXNlOiAnLCBlcnIpO1xuXHRcdHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgYmFja3VwIGNvZGVzIHRvIGRhdGFiYXNlJyk7XG5cdH1cbn1cblxuLy8gR2V0IGJhY2t1cCBjb2RlcyBmcm9tIHRoZSBkYXRhYmFzZVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmFja3VwQ29kZXNGcm9tRGF0YWJhc2UoXG5cdGlkOiBzdHJpbmdcbik6IFByb21pc2U8QmFja3VwQ29kZVtdIHwgdW5kZWZpbmVkPiB7XG5cdGxldCBsb2dnZXIgPSBhd2FpdCBzZXR1cExvZ2dlcigpO1xuXHRsZXQgVXNlck1mYSA9IGF3YWl0IFVzZXJNZmFNb2RlbFByb21pc2U7IC8vIGF3YWl0IHRoZSBVc2VyIG1vZGVsIHdoZW4gbmVlZGVkXG5cblx0dHJ5IHtcblx0XHRsZXQgdXNlciA9IGF3YWl0IFVzZXJNZmEuZmluZEJ5UGsoaWQpOyAvLyBmaW5kIHVzZXIgYnkgcHJpbWFyeSBrZXlcblx0XHRpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgZm91bmQnKTtcblxuXHRcdC8vIGFzc3VtZSB1c2VyLmJhY2t1cENvZGVzIGlzIGEgc3RyaW5nW10gb3IgbnVsbCwgY29udmVydCBpdCB0byBCYWNrdW9wQ29kZVtdIG9yIHVuZGVmaW5lZFxuXHRcdGxldCBiYWNrdXBDb2RlcyA9IHVzZXIuYmFja3VwQ29kZXMgYXMgc3RyaW5nW10gfCBudWxsO1xuXG5cdFx0aWYgKGJhY2t1cENvZGVzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkOyAvLyAqREVWLU5PVEUqIHByb2JhYmx5IG5lZWQgdG8gY29uZmlndXJlIHRoaXMgbGF0ZXJcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHN0cmluZ1tdIHRvIEJhY2t1cENvZGVbXVxuXHRcdHJldHVybiBiYWNrdXBDb2Rlcy5tYXAoKGNvZGUpID0+ICh7IGNvZGUsIHVzZWQ6IGZhbHNlIH0pIGFzIEJhY2t1cENvZGUpO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRsb2dnZXIuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGJhY2t1cCBjb2RlcyBmcm9tIGRhdGFiYXNlOiAnLCBlcnIpO1xuXHRcdHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJldHJpZXZlIGJhY2t1cCBjb2RlcyBmcm9tIGRhdGFiYXNlJyk7XG5cdH1cbn1cblxuLy8gVXBkYXRlIGJhY2t1cCBjb2RlcyBpbiB0aGUgZGF0YWJhc2VcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUJhY2t1cENvZGVzSW5EYXRhYmFzZShcblx0aWQ6IHN0cmluZyxcblx0YmFja3VwQ29kZXM6IEJhY2t1cENvZGVbXVxuKTogUHJvbWlzZTx2b2lkPiB7XG5cdGxldCBsb2dnZXIgPSBhd2FpdCBzZXR1cExvZ2dlcigpO1xuXHRsZXQgVXNlck1mYSA9IGF3YWl0IFVzZXJNZmFNb2RlbFByb21pc2U7IC8vIGF3YWl0IHRoZSBVc2VyTWZhIG1vZGVsIHdoZW4gbmVlZGVkXG5cblx0dHJ5IHtcblx0XHRsZXQgdXNlciA9IGF3YWl0IFVzZXJNZmEuZmluZEJ5UGsoaWQpOyAvLyBmaW5kIHVzZXIgYnkgcHJpbWFyeSBrZXlcblx0XHRpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgZm91bmQnKTtcblxuXHRcdC8vIG1hcCB0aGUgY29kZXMgZWxlbWVudCBvZiBiYWNrdXBDb2RlcyB0byBhbiBhcnJheSBvZiBzdHJpbmdzXG5cdFx0bGV0IGJhY2t1cENvZGVzQXNTdHJpbmdzID0gYmFja3VwQ29kZXMubWFwKChjb2RlT2JqKSA9PiBjb2RlT2JqLmNvZGUpO1xuXG5cdFx0Ly8gYXNzaWduIHRoZSBhcnJheSBvZiBzdHJpbmdzIHRvIHVzZXIuYmFja3VwQ29kZXNcblx0XHR1c2VyLmJhY2t1cENvZGVzID0gYmFja3VwQ29kZXNBc1N0cmluZ3M7XG5cdFx0YXdhaXQgdXNlci5zYXZlKCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGxvZ2dlci5lcnJvcignRXJyb3IgdXBkYXRpbmcgYmFja3VwIGNvZGVzIGluIGRhdGFiYXNlOiAnLCBlcnIpO1xuXHRcdHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBiYWNrdXAgY29kZXMgaW4gZGF0YWJhc2UnKTtcblx0fVxufVxuXG5leHBvcnQge1xuXHRnZW5lcmF0ZUJhY2t1cENvZGVzLFxuXHRnZXRCYWNrdXBDb2Rlc0Zyb21EYXRhYmFzZSxcblx0c2F2ZUJhY2t1cENvZGVzVG9EYXRhYmFzZSxcblx0dmVyaWZ5QmFja3VwQ29kZVxufTtcbiJdfQ==
