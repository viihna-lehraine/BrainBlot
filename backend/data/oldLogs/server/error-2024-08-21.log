2024-08-21 00:24:40, info: Executing (default): SELECT 1+1 AS result
2024-08-21 00:31:21, info: Executing (default): SELECT 1+1 AS result
2024-08-21 00:36:17, info: Executing (default): SELECT 1+1 AS result
2024-08-21 00:52:26, info: Executing (default): SELECT 1+1 AS result
2024-08-21 00:58:10, info: Executing (default): SELECT 1+1 AS result
2024-08-21 00:58:10, info: Connection has been established successfully.
2024-08-21 00:58:10, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 00:58:10, info: Blacklist and range_check module loaded successfully.
2024-08-21 00:58:10, info: Test routes loaded
2024-08-21 00:58:10, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 00:58:10, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 00:58:10, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 01:05:51, info: Executing (default): SELECT 1+1 AS result
2024-08-21 01:05:51, info: Connection has been established successfully.
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 01:05:51, info: Blacklist and range_check module loaded successfully.
2024-08-21 01:05:51, info: Test routes loaded
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 01:05:51, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 01:05:51, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 01:05:51, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 01:05:51, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 01:05:51, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 01:05:51, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 01:05:51, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 01:05:51, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 01:05:51, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 01:05:51, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "userid" UUID NOT NULL UNIQUE REFERENCES "Users" ("userid"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false REFERENCES "Users" ("isMfaEnabled"), "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:12:00, info: Executing (default): SELECT 1+1 AS result
2024-08-21 02:12:01, info: Connection has been established successfully.
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:12:01, info: Blacklist and range_check module loaded successfully.
2024-08-21 02:12:01, info: Test routes loaded
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:12:01, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 02:12:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:12:01, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:12:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:12:01, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 02:12:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:12:01, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:12:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:12:01, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:12:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false REFERENCES "Users" ("isMfaEnabled"), "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:27:56, info: Executing (default): SELECT 1+1 AS result
2024-08-21 02:27:56, info: Connection has been established successfully.
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:27:57, info: Blacklist and range_check module loaded successfully.
2024-08-21 02:27:57, info: Test routes loaded
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:27:57, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 02:27:57, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:27:57, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:27:57, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:27:57, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 02:27:57, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:27:57, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:27:57, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:27:57, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserSessions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "sessionId"   SERIAL UNIQUE , "userId" UUID NOT NULL, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL, "isActive" BOOLEAN DEFAULT true, PRIMARY KEY ("id","sessionId"));
2024-08-21 02:27:57, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): SELECT 1+1 AS result
2024-08-21 02:34:58, info: Connection has been established successfully.
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:34:58, info: Blacklist and range_check module loaded successfully.
2024-08-21 02:34:58, info: Test routes loaded
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:34:58, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 02:34:58, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:34:58, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:34:58, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:34:58, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 02:34:58, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:34:58, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:34:58, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:34:58, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserSessions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "sessionId"   SERIAL UNIQUE , "userId" UUID NOT NULL, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL, "isActive" BOOLEAN DEFAULT true, PRIMARY KEY ("id","sessionId"));
2024-08-21 02:34:58, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): SELECT 1+1 AS result
2024-08-21 02:46:01, info: Connection has been established successfully.
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:46:01, info: Blacklist and range_check module loaded successfully.
2024-08-21 02:46:01, info: Test routes loaded
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:46:01, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 02:46:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:46:01, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:46:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:46:01, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 02:46:01, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:46:01, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:46:01, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:46:01, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserSessions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "sessionId"   SERIAL UNIQUE , "userId" UUID NOT NULL, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL, "isActive" BOOLEAN DEFAULT true, PRIMARY KEY ("id","sessionId"));
2024-08-21 02:46:01, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:21, info: Executing (default): SELECT 1+1 AS result
2024-08-21 02:47:21, info: Connection has been established successfully.
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:47:22, info: Blacklist and range_check module loaded successfully.
2024-08-21 02:47:22, info: Test routes loaded
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:47:22, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 02:47:22, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:47:22, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:47:22, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:47:22, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 02:47:22, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:47:22, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:47:22, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:47:22, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserSessions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "sessionId"   SERIAL UNIQUE , "userId" UUID NOT NULL, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL, "isActive" BOOLEAN DEFAULT true, PRIMARY KEY ("id","sessionId"));
2024-08-21 02:47:22, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): SELECT 1+1 AS result
2024-08-21 02:54:52, info: Connection has been established successfully.
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:54:52, info: Blacklist and range_check module loaded successfully.
2024-08-21 02:54:52, info: Test routes loaded
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:54:52, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 02:54:52, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:54:52, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:54:52, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:54:52, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 02:54:52, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:54:52, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:54:52, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:54:52, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserSessions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "sessionId"   SERIAL UNIQUE , "userId" UUID NOT NULL, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL, "isActive" BOOLEAN DEFAULT true, PRIMARY KEY ("id","sessionId"));
2024-08-21 02:54:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): SELECT 1+1 AS result
2024-08-21 02:55:56, info: Connection has been established successfully.
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:55:56, info: Blacklist and range_check module loaded successfully.
2024-08-21 02:55:56, info: Test routes loaded
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 02:55:56, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 02:55:56, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:55:56, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 02:55:56, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 02:55:56, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 02:55:56, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 02:55:56, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 02:55:56, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 02:55:56, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserSessions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "sessionId"   SERIAL UNIQUE , "userId" UUID NOT NULL, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL, "isActive" BOOLEAN DEFAULT true, PRIMARY KEY ("id","sessionId"));
2024-08-21 02:55:56, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): SELECT 1+1 AS result
2024-08-21 03:38:39, info: Connection has been established successfully.
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 03:38:39, info: Blacklist and range_check module loaded successfully.
2024-08-21 03:38:39, info: Test routes loaded
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Users' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'AuditLogs' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'DataShareOptions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'Devices' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FailedLoginAttempts' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeedbackSurveys' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'FeatureRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'GuestbookEntries' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'MultiFactorAuthSetups' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'RecoveryMethods' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SecurityEvents' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'SupportRequests' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserMfas' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'UserSessions' AND tc.table_catalog = 'guestbook_dev'
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "Users" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" UUID NOT NULL UNIQUE , "userid"   SERIAL UNIQUE, "username" VARCHAR(255) NOT NULL UNIQUE, "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL UNIQUE, "isAccountVerified" BOOLEAN DEFAULT false, "resetPasswordToken" VARCHAR(255) DEFAULT NULL, "resetPasswordExpires" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "AuditLogs" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "AuditLogs" ("auditId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "actionType" VARCHAR(255) NOT NULL, "actionDescription" TEXT, "affectedResource" VARCHAR(255), "previousValue" TEXT, "newValue" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "auditLogDate" TIMESTAMP WITH TIME ZONE NOT NULL, "auditLogUpdateDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("auditId"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "DataShareOptions" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "DataShareOptions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "trackingPixelOption" BOOLEAN NOT NULL DEFAULT false, "featureUsageOption" BOOLEAN NOT NULL DEFAULT false, "pageViewsOption" BOOLEAN NOT NULL DEFAULT false, "interactionDataOption" BOOLEAN NOT NULL DEFAULT false, "deviceTypeOption" BOOLEAN NOT NULL DEFAULT false, "browserInfoOption" BOOLEAN NOT NULL DEFAULT false, "operatingSystemOption" BOOLEAN NOT NULL DEFAULT false, "randomAnonSurveyOption" BOOLEAN NOT NULL DEFAULT false, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "Devices" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "Devices" ("deviceId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "deviceName" VARCHAR(255), "deviceType" VARCHAR(255), "os" VARCHAR(255), "browser" VARCHAR(255), "ipAddress" VARCHAR(255) NOT NULL, "lastUsed" TIMESTAMP WITH TIME ZONE, "isTrusted" BOOLEAN DEFAULT false, "creationDate" TIMESTAMP WITH TIME ZONE NOT NULL, "lastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("deviceId","id"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FailedLoginAttempts" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "FailedLoginAttempts" ("attemptId"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "attemptDate" TIMESTAMP WITH TIME ZONE NOT NULL, "isLocked" BOOLEAN DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("attemptId"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FeedbackSurveys" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeedbackSurveys" ("surveyId"   SERIAL UNIQUE , "questionGeneralApproval" INTEGER, "questionServiceQuality" INTEGER, "questionEaseOfUse" INTEGER, "questionUserSupport" INTEGER, "questionHelpGuides" INTEGER, "questionIsPremiumUser" BOOLEAN, "questionPremiumValue" INTEGER, "questionLikelihoodToRecommend" INTEGER, "questionUsefulFeaturesAndAspects" JSON DEFAULT '[]', "questionFeaturesThatNeedImprovement" JSON DEFAULT '[]', "questionOpenEndedLikeTheMost" TEXT DEFAULT '', "questionOpenEndedWhatCanWeImprove" TEXT DEFAULT '', "questionDemoHeardAboutUs" INTEGER, "questionDemoAgeGroup" INTEGER, "questionDemoGender" VARCHAR(255), "questionDemoRegion" VARCHAR(255), "questionDemoLangPref" VARCHAR(255), "questionFinalThoughts" TEXT DEFAULT '', "hasOptedInForFollowUp" BOOLEAN DEFAULT false, "email" VARCHAR(255) DEFAULT '', "surveyDate" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("surveyId"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "FeatureRequests" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "FeatureRequests" ("featureRequestNumber"  SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "email" VARCHAR(255) DEFAULT NULL, "featureRequestType" TEXT NOT NULL DEFAULT NULL, "featureRequestContent" TEXT NOT NULL DEFAULT NULL, "canFollowUpFeatureRequest" BOOLEAN NOT NULL DEFAULT false, "featureRequestOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "featureRequestCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("featureRequestNumber"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "GuestbookEntries" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "GuestbookEntries" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "guestName" VARCHAR(255), "guestEmail" VARCHAR(255), "guestMessage" TEXT NOT NULL, "guestMessageStyles" JSON, "entryDate" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "MultiFactorAuthSetups" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method";
2024-08-21 03:38:39, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 03:38:39, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_MultiFactorAuthSetups_method"; DO 'BEGIN CREATE TYPE "public"."enum_MultiFactorAuthSetups_method" AS ENUM(''totp'', ''email'', ''yubico'', ''fido2'', ''passkey''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 03:38:39, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "MultiFactorAuthSetups" ("mfaId"   SERIAL UNIQUE , "id" UUID NOT NULL UNIQUE REFERENCES "Users" ("id"), "userId" UUID NOT NULL, "method" "public"."enum_MultiFactorAuthSetups_method" NOT NULL, "secret" VARCHAR(255), "publicKey" TEXT, "counter" INTEGER, "isActive" BOOLEAN NOT NULL DEFAULT true, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("mfaId"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "RecoveryMethods" CASCADE;
2024-08-21 03:38:39, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod";
2024-08-21 03:38:39, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 03:38:39, info: Executing (default): DROP TYPE IF EXISTS "public"."enum_RecoveryMethods_recoveryMethod"; DO 'BEGIN CREATE TYPE "public"."enum_RecoveryMethods_recoveryMethod" AS ENUM(''email'', ''backupCodes''); EXCEPTION WHEN duplicate_object THEN null; END';
2024-08-21 03:38:39, info: Executing (default): WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "RecoveryMethods" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isRecoveryActive" BOOLEAN NOT NULL DEFAULT false, "recoveryId" UUID NOT NULL UNIQUE , "recoveryMethod" "public"."enum_RecoveryMethods_recoveryMethod", "backupCodes" VARCHAR(255)[], "recoveryLastUpdated" TIMESTAMP WITH TIME ZONE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","recoveryId"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "SecurityEvents" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "SecurityEvents" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "eventId"  SERIAL UNIQUE, "eventType" VARCHAR(255) NOT NULL, "eventDescription" TEXT, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "securityEventDate" TIMESTAMP WITH TIME ZONE NOT NULL, "securityEventLastUpdated" TIMESTAMP WITH TIME ZONE NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "SupportRequests" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "SupportRequests" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "email" VARCHAR(255) NOT NULL, "supportTicketNumber"  SERIAL UNIQUE, "supportType" TEXT NOT NULL, "supportContent" TEXT NOT NULL, "isSupportTicketOpen" BOOLEAN NOT NULL DEFAULT true, "supportTicketOpenDate" TIMESTAMP WITH TIME ZONE NOT NULL, "supportTicketCloseDate" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "UserMfas" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserMfas" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "isMfaEnabled" BOOLEAN NOT NULL DEFAULT false, "backupCodes" VARCHAR(255)[] DEFAULT NULL, "isEmail2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isTotpl2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isYubicoOtp2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isU2f2faEnabled" BOOLEAN NOT NULL DEFAULT false, "isPasskeyEnabled" BOOLEAN NOT NULL DEFAULT false, "totpSecret" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpPublicId" VARCHAR(255) DEFAULT NULL UNIQUE, "yubicoOtpSecretKey" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2CredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "fido2PublicKey" TEXT DEFAULT NULL, "fido2Counter" INTEGER DEFAULT NULL, "fido2AttestationFormat" VARCHAR(255) DEFAULT NULL, "passkeyCredentialId" VARCHAR(255) DEFAULT NULL UNIQUE, "passkeyPublicKey" TEXT DEFAULT NULL UNIQUE, "passkeyCounter" INTEGER DEFAULT NULL, "passkeyAttestationFormat" VARCHAR(255) DEFAULT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:38:39, info: Executing (default): DROP TABLE IF EXISTS "UserSessions" CASCADE;
2024-08-21 03:38:39, info: Executing (default): CREATE TABLE IF NOT EXISTS "UserSessions" ("id" UUID NOT NULL UNIQUE  REFERENCES "Users" ("id"), "sessionId"   SERIAL UNIQUE , "userId" UUID NOT NULL, "ipAddress" VARCHAR(255) NOT NULL, "userAgent" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NULL, "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL, "isActive" BOOLEAN DEFAULT true, PRIMARY KEY ("id","sessionId"));
2024-08-21 03:38:39, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT 1+1 AS result
2024-08-21 03:45:23, info: Connection has been established successfully.
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 03:45:23, info: Blacklist and range_check module loaded successfully.
2024-08-21 03:45:23, info: Test routes loaded
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 03:45:23, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 03:45:23, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:45:23, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 03:45:23, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:44, info: Executing (default): SELECT 1+1 AS result
2024-08-21 03:46:44, info: Connection has been established successfully.
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 03:46:45, info: Blacklist and range_check module loaded successfully.
2024-08-21 03:46:45, info: Test routes loaded
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 03:46:45, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 03:46:45, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:46:45, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 03:46:45, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:05, info: Executing (default): SELECT 1+1 AS result
2024-08-21 03:50:05, info: Connection has been established successfully.
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 03:50:06, info: Blacklist and range_check module loaded successfully.
2024-08-21 03:50:06, info: Test routes loaded
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 03:50:06, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 03:50:06, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:50:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 03:50:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT 1+1 AS result
2024-08-21 03:52:06, info: Connection has been established successfully.
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 03:52:06, info: Blacklist and range_check module loaded successfully.
2024-08-21 03:52:06, info: Test routes loaded
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 03:52:06, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 03:52:06, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:06, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 03:52:06, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:32, info: Executing (default): SELECT 1+1 AS result
2024-08-21 03:52:32, info: Connection has been established successfully.
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 03:52:33, info: Blacklist and range_check module loaded successfully.
2024-08-21 03:52:33, info: Test routes loaded
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 03:52:33, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 03:52:33, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:52:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 03:52:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:40, info: Executing (default): SELECT 1+1 AS result
2024-08-21 03:56:40, info: Connection has been established successfully.
2024-08-21 03:56:40, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 03:56:40, info: Blacklist and range_check module loaded successfully.
2024-08-21 03:56:40, info: Test routes loaded
2024-08-21 03:56:40, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:40, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 03:56:40, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:40, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 03:56:40, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:40, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 03:56:40, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:40, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 03:56:40, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:40, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:41, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:41, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:41, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 03:56:41, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:41, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 03:56:41, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:41, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:41, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:41, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 03:56:41, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 03:56:41, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT 1+1 AS result
2024-08-21 04:15:07, info: Connection has been established successfully.
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 04:15:07, info: Blacklist and range_check module loaded successfully.
2024-08-21 04:15:07, info: Test routes loaded
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 04:15:07, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 04:15:07, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:15:07, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 04:15:07, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT 1+1 AS result
2024-08-21 04:23:36, info: Connection has been established successfully.
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 04:23:36, info: Blacklist and range_check module loaded successfully.
2024-08-21 04:23:36, info: Test routes loaded
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 04:23:36, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 04:23:36, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:36, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 04:23:36, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:54, info: Executing (default): SELECT 1+1 AS result
2024-08-21 04:23:54, info: Connection has been established successfully.
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 04:23:55, info: Blacklist and range_check module loaded successfully.
2024-08-21 04:23:55, info: Test routes loaded
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 04:23:55, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 04:23:55, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:23:55, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 04:23:55, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT 1+1 AS result
2024-08-21 04:27:52, info: Connection has been established successfully.
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 04:27:52, info: Blacklist and range_check module loaded successfully.
2024-08-21 04:27:52, info: Test routes loaded
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 04:27:52, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 04:27:52, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:27:52, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 04:27:52, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT 1+1 AS result
2024-08-21 04:30:04, info: Connection has been established successfully.
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 04:30:04, info: Blacklist and range_check module loaded successfully.
2024-08-21 04:30:04, info: Test routes loaded
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 04:30:04, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 04:30:04, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 04:30:04, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 04:30:04, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:01, info: Executing (default): SELECT 1+1 AS result
2024-08-21 05:28:01, info: Connection has been established successfully.
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 05:28:02, info: Blacklist and range_check module loaded successfully.
2024-08-21 05:28:02, info: Test routes loaded
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 05:28:02, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 05:28:02, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:28:02, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 05:28:02, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT 1+1 AS result
2024-08-21 05:46:47, info: Connection has been established successfully.
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 05:46:47, info: Blacklist and range_check module loaded successfully.
2024-08-21 05:46:47, info: Test routes loaded
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 05:46:47, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 05:46:47, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:46:47, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 05:46:47, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT 1+1 AS result
2024-08-21 05:48:33, info: Connection has been established successfully.
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Users'
2024-08-21 05:48:33, info: Blacklist and range_check module loaded successfully.
2024-08-21 05:48:33, info: Test routes loaded
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'AuditLogs'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'AuditLogs' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'DataShareOptions'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'DataShareOptions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Devices'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Devices' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FailedLoginAttempts'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FailedLoginAttempts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeedbackSurveys'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeedbackSurveys' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'FeatureRequests'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'FeatureRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'GuestbookEntries'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'GuestbookEntries' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'MultiFactorAuthSetups'
2024-08-21 05:48:33, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_MultiFactorAuthSetups_method' GROUP BY 1
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'MultiFactorAuthSetups' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'RecoveryMethods'
2024-08-21 05:48:33, info: Executing (default): SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = 'public' AND t.typname='enum_RecoveryMethods_recoveryMethod' GROUP BY 1
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'RecoveryMethods' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SecurityEvents'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SecurityEvents' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'SupportRequests'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'SupportRequests' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserMfas'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserMfas' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 05:48:33, info: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'UserSessions'
2024-08-21 05:48:33, info: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'UserSessions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2024-08-21 06:20:41, info: Executing (default): SELECT 1+1 AS result
2024-08-21 06:20:41, info: Connection has been established successfully.
2024-08-21 06:20:42, info: Blacklist and range_check module loaded successfully.
2024-08-21 06:20:42, info: Test routes loaded
2024-08-21 06:35:59, info: Executing (default): SELECT 1+1 AS result
2024-08-21 06:35:59, info: Connection has been established successfully.
2024-08-21 06:35:59, info: Blacklist and range_check module loaded successfully.
2024-08-21 06:35:59, info: Test routes loaded
