import bcrypt from 'bcrypt';
import crypto from 'crypto';
import setupLogger from '../../config/logger.mjs';
import UserMfa from '../../models/UserMfa.mjs';
const logger = setupLogger();
// Generate Backup Coedes
async function generateBackupCodes(id) {
	const backupCodes = [];
	for (let i = 0; i < 16; i++) {
		const code = crypto.randomBytes(4).toString('hex'); // 8-character hex code
		const hashedCode = await bcrypt.hash(code, 10);
		backupCodes.push({ code: hashedCode, used: false });
	}
	// store backupCodes in the database associated with the user's id
	await saveBackupCodesToDatabase(id, backupCodes);
	// return only the plain codes as strings
	return backupCodes.map(backupCode => backupCode.code);
}
// Verify a Backup Code
async function verifyBackupCode(id, inputCode) {
	const storedCodes = await getBackupCodesFromDatabase(id);
	if (storedCodes) {
		for (let i = 0; i < storedCodes.length; i++) {
			const match = await bcrypt.compare(inputCode, storedCodes[i].code);
			if (match && !storedCodes[i].used) {
				storedCodes[i].used = true;
				await updateBackupCodesInDatabase(id, storedCodes); // mark the code as used
				return true; // successful verification
			}
		}
	} else {
		logger.error('No backup codes found for user');
		return false; // no backup codes found
	}
	return false; // verification failed
}
// Save backup codes to the database
async function saveBackupCodesToDatabase(id, backupCodes) {
	try {
		const user = await UserMfa.findByPk(id); // find user by primary key
		if (!user) throw new Error('User not found');
		// map the codes element of backupCodes to an array of strings
		const backupCodesAsStrings = backupCodes.map(codeObj => codeObj.code);
		// assign the array of strings to user.backupCodes
		user.backupCodes = backupCodesAsStrings;
		await user.save();
	} catch (err) {
		logger.error('Error saving backup codes to database: ', err);
		throw new Error('Failed to save backup codes to database');
	}
}
// Get backup codes from the database
async function getBackupCodesFromDatabase(id) {
	const logger = await setupLogger();
	try {
		const user = await UserMfa.findByPk(id); // find user by primary key
		if (!user) throw new Error('User not found');
		// assume user.backupCodes is a string[] or null, convert it to BackuopCode[] or undefined
		const backupCodes = user.backupCodes;
		if (backupCodes === null) {
			return undefined; // *DEV-NOTE* probably need to configure this later
		}
		// convert string[] to BackupCode[]
		return backupCodes.map(code => ({ code, used: false }));
	} catch (err) {
		logger.error('Error fetching backup codes from database: ', err);
		throw new Error('Failed to retrieve backup codes from database');
	}
}
// Update backup codes in the database
async function updateBackupCodesInDatabase(id, backupCodes) {
	try {
		const user = await UserMfa.findByPk(id); // find user by primary key
		if (!user) throw new Error('User not found');
		// map the codes element of backupCodes to an array of strings
		const backupCodesAsStrings = backupCodes.map(codeObj => codeObj.code);
		// assign the array of strings to user.backupCodes
		user.backupCodes = backupCodesAsStrings;
		await user.save();
	} catch (err) {
		logger.error('Error updating backup codes in database: ', err);
		throw new Error('Failed to update backup codes in database');
	}
}
export {
	generateBackupCodes,
	getBackupCodesFromDatabase,
	saveBackupCodesToDatabase,
	verifyBackupCode
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja3VwQ29kZVV0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvYXV0aC9iYWNrdXBDb2RlVXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sV0FBVyxNQUFNLHFCQUFxQixDQUFDO0FBQzlDLE9BQU8sT0FBTyxNQUFNLHNCQUFzQixDQUFDO0FBTzNDLE1BQU0sTUFBTSxHQUFHLFdBQVcsRUFBRSxDQUFDO0FBRTdCLHlCQUF5QjtBQUN6QixLQUFLLFVBQVUsbUJBQW1CLENBQUMsRUFBVTtJQUM1QyxNQUFNLFdBQVcsR0FBaUIsRUFBRSxDQUFDO0lBQ3JDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUM3QixNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLHVCQUF1QjtRQUMzRSxNQUFNLFVBQVUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQy9DLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRCxrRUFBa0U7SUFDbEUsTUFBTSx5QkFBeUIsQ0FBQyxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFFakQseUNBQXlDO0lBQ3pDLE9BQU8sV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN2RCxDQUFDO0FBRUQsdUJBQXVCO0FBQ3ZCLEtBQUssVUFBVSxnQkFB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LE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0FBQ0YsQ0FBQztBQUVELHNDQUFzQztBQUN0QyxLQUFLLFVBQVUsMkJBQTJCLENBQ3pDLEVBQVUsRUFDVixXQUF5QjtJQUV6QixJQUFJLENBQUM7UUFDSixNQUFNLElBQUksR0FBRyxNQUFNLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQywyQkFBMkI7UUFDcEUsSUFBSSxDQUFDLElBQUk7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFN0MsOERBQThEO1FBQzlELE1BQU0sb0JBQW9CLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV0RSxrREFBa0Q7UUFDbEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxvQkFBb0IsQ0FBQztRQUN4QyxNQUFNLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNkLE1BQU0sQ0FBQyxLQUFLLENBQUMsMkNBQTJDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDL0QsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO0lBQzlELENBQUM7QUFDRixDQUFDO0FBRUQsT0FBTyxFQUNOLG1CQUFtQixFQUNuQiwwQkFBMEIsRUFDMUIseUJBQXlCLEVBQ3pCLGdCQUFnQixFQUNoQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJjcnlwdCBmcm9tICdiY3J5cHQnO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHNldHVwTG9nZ2VyIGZyb20gJy4uLy4uL2NvbmZpZy9sb2dnZXInO1xuaW1wb3J0IFVzZXJNZmEgZnJvbSAnLi4vLi4vbW9kZWxzL1VzZXJNZmEnO1xuXG5pbnRlcmZhY2UgQmFja3VwQ29kZSB7XG5cdGNvZGU6IHN0cmluZztcblx0dXNlZDogYm9vbGVhbjtcbn1cblxuY29uc3QgbG9nZ2VyID0gc2V0dXBMb2dnZXIoKTtcblxuLy8gR2VuZXJhdGUgQmFja3VwIENvZWRlc1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVCYWNrdXBDb2RlcyhpZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuXHRjb25zdCBiYWNrdXBDb2RlczogQmFja3VwQ29kZVtdID0gW107XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHRcdGNvbnN0IGNvZGUgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkudG9TdHJpbmcoJ2hleCcpOyAvLyA4LWNoYXJhY3RlciBoZXggY29kZVxuXHRcdGNvbnN0IGhhc2hlZENvZGUgPSBhd2FpdCBiY3J5cHQuaGFzaChjb2RlLCAxMCk7XG5cdFx0YmFja3VwQ29kZXMucHVzaCh7IGNvZGU6IGhhc2hlZENvZGUsIHVzZWQ6IGZhbHNlIH0pO1xuXHR9XG5cblx0Ly8gc3RvcmUgYmFja3VwQ29kZXMgaW4gdGhlIGRhdGFiYXNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlcidzIGlkXG5cdGF3YWl0IHNhdmVCYWNrdXBDb2Rlc1RvRGF0YWJhc2UoaWQsIGJhY2t1cENvZGVzKTtcblxuXHQvLyByZXR1cm4gb25seSB0aGUgcGxhaW4gY29kZXMgYXMgc3RyaW5nc1xuXHRyZXR1cm4gYmFja3VwQ29kZXMubWFwKGJhY2t1cENvZGUgPT4gYmFja3VwQ29kZS5jb2RlKTtcbn1cblxuLy8gVmVyaWZ5IGEgQmFja3VwIENvZGVcbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUJhY2t1cENvZGUoXG5cdGlkOiBzdHJpbmcsXG5cdGlucHV0Q29kZTogc3RyaW5nXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0Y29uc3Qgc3RvcmVkQ29kZXMgPSBhd2FpdCBnZXRCYWNrdXBDb2Rlc0Zyb21EYXRhYmFzZShpZCk7XG5cblx0aWYgKHN0b3JlZENvZGVzKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdG9yZWRDb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBhd2FpdCBiY3J5cHQuY29tcGFyZShpbnB1dENvZGUsIHN0b3JlZENvZGVzW2ldLmNvZGUpO1xuXHRcdFx0aWYgKG1hdGNoICYmICFzdG9yZWRDb2Rlc1tpXS51c2VkKSB7XG5cdFx0XHRcdHN0b3JlZENvZGVzW2ldLnVzZWQgPSB0cnVlO1xuXHRcdFx0XHRhd2FpdCB1cGRhdGVCYWNrdXBDb2Rlc0luRGF0YWJhc2UoaWQsIHN0b3JlZENvZGVzKTsgLy8gbWFyayB0aGUgY29kZSBhcyB1c2VkXG5cdFx0XHRcdHJldHVybiB0cnVlOyAvLyBzdWNjZXNzZnVsIHZlcmlmaWNhdGlvblxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRsb2dnZXIuZXJyb3IoJ05vIGJhY2t1cCBjb2RlcyBmb3VuZCBmb3IgdXNlcicpO1xuXHRcdHJldHVybiBmYWxzZTsgLy8gbm8gYmFja3VwIGNvZGVzIGZvdW5kXG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7IC8vIHZlcmlmaWNhdGlvbiBmYWlsZWRcbn1cblxuLy8gU2F2ZSBiYWNrdXAgY29kZXMgdG8gdGhlIGRhdGFiYXNlXG5hc3luYyBmdW5jdGlvbiBzYXZlQmFja3VwQ29kZXNUb0RhdGFiYXNlKFxuXHRpZDogc3RyaW5nLFxuXHRiYWNrdXBDb2RlczogQmFja3VwQ29kZVtdXG4pOiBQcm9taXNlPHZvaWQ+IHtcblx0dHJ5IHtcblx0XHRjb25zdCB1c2VyID0gYXdhaXQgVXNlck1mYS5maW5kQnlQayhpZCk7IC8vIGZpbmQgdXNlciBieSBwcmltYXJ5IGtleVxuXHRcdGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpO1xuXG5cdFx0Ly8gbWFwIHRoZSBjb2RlcyBlbGVtZW50IG9mIGJhY2t1cENvZGVzIHRvIGFuIGFycmF5IG9mIHN0cmluZ3Ncblx0XHRjb25zdCBiYWNrdXBDb2Rlc0FzU3RyaW5ncyA9IGJhY2t1cENvZGVzLm1hcChjb2RlT2JqID0+IGNvZGVPYmouY29kZSk7XG5cblx0XHQvLyBhc3NpZ24gdGhlIGFycmF5IG9mIHN0cmluZ3MgdG8gdXNlci5iYWNrdXBDb2Rlc1xuXHRcdHVzZXIuYmFja3VwQ29kZXMgPSBiYWNrdXBDb2Rlc0FzU3RyaW5ncztcblx0XHRhd2FpdCB1c2VyLnNhdmUoKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0bG9nZ2VyLmVycm9yKCdFcnJvciBzYXZpbmcgYmFja3VwIGNvZGVzIHRvIGRhdGFiYXNlOiAnLCBlcnIpO1xuXHRcdHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgYmFja3VwIGNvZGVzIHRvIGRhdGFiYXNlJyk7XG5cdH1cbn1cblxuLy8gR2V0IGJhY2t1cCBjb2RlcyBmcm9tIHRoZSBkYXRhYmFzZVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmFja3VwQ29kZXNGcm9tRGF0YWJhc2UoXG5cdGlkOiBzdHJpbmdcbik6IFByb21pc2U8QmFja3VwQ29kZVtdIHwgdW5kZWZpbmVkPiB7XG5cdGNvbnN0IGxvZ2dlciA9IGF3YWl0IHNldHVwTG9nZ2VyKCk7XG5cblx0dHJ5IHtcblx0XHRjb25zdCB1c2VyID0gYXdhaXQgVXNlck1mYS5maW5kQnlQayhpZCk7IC8vIGZpbmQgdXNlciBieSBwcmltYXJ5IGtleVxuXHRcdGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpO1xuXG5cdFx0Ly8gYXNzdW1lIHVzZXIuYmFja3VwQ29kZXMgaXMgYSBzdHJpbmdbXSBvciBudWxsLCBjb252ZXJ0IGl0IHRvIEJhY2t1b3BDb2RlW10gb3IgdW5kZWZpbmVkXG5cdFx0Y29uc3QgYmFja3VwQ29kZXMgPSB1c2VyLmJhY2t1cENvZGVzIGFzIHN0cmluZ1tdIHwgbnVsbDtcblxuXHRcdGlmIChiYWNrdXBDb2RlcyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDsgLy8gKkRFVi1OT1RFKiBwcm9iYWJseSBuZWVkIHRvIGNvbmZpZ3VyZSB0aGlzIGxhdGVyXG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCBzdHJpbmdbXSB0byBCYWNrdXBDb2RlW11cblx0XHRyZXR1cm4gYmFja3VwQ29kZXMubWFwKGNvZGUgPT4gKHsgY29kZSwgdXNlZDogZmFsc2UgfSkgYXMgQmFja3VwQ29kZSk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGxvZ2dlci5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYmFja3VwIGNvZGVzIGZyb20gZGF0YWJhc2U6ICcsIGVycik7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmV0cmlldmUgYmFja3VwIGNvZGVzIGZyb20gZGF0YWJhc2UnKTtcblx0fVxufVxuXG4vLyBVcGRhdGUgYmFja3VwIGNvZGVzIGluIHRoZSBkYXRhYmFzZVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlQmFja3VwQ29kZXNJbkRhdGFiYXNlKFxuXHRpZDogc3RyaW5nLFxuXHRiYWNrdXBDb2RlczogQmFja3VwQ29kZVtdXG4pOiBQcm9taXNlPHZvaWQ+IHtcblx0dHJ5IHtcblx0XHRjb25zdCB1c2VyID0gYXdhaXQgVXNlck1mYS5maW5kQnlQayhpZCk7IC8vIGZpbmQgdXNlciBieSBwcmltYXJ5IGtleVxuXHRcdGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpO1xuXG5cdFx0Ly8gbWFwIHRoZSBjb2RlcyBlbGVtZW50IG9mIGJhY2t1cENvZGVzIHRvIGFuIGFycmF5IG9mIHN0cmluZ3Ncblx0XHRjb25zdCBiYWNrdXBDb2Rlc0FzU3RyaW5ncyA9IGJhY2t1cENvZGVzLm1hcChjb2RlT2JqID0+IGNvZGVPYmouY29kZSk7XG5cblx0XHQvLyBhc3NpZ24gdGhlIGFycmF5IG9mIHN0cmluZ3MgdG8gdXNlci5iYWNrdXBDb2Rlc1xuXHRcdHVzZXIuYmFja3VwQ29kZXMgPSBiYWNrdXBDb2Rlc0FzU3RyaW5ncztcblx0XHRhd2FpdCB1c2VyLnNhdmUoKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0bG9nZ2VyLmVycm9yKCdFcnJvciB1cGRhdGluZyBiYWNrdXAgY29kZXMgaW4gZGF0YWJhc2U6ICcsIGVycik7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGJhY2t1cCBjb2RlcyBpbiBkYXRhYmFzZScpO1xuXHR9XG59XG5cbmV4cG9ydCB7XG5cdGdlbmVyYXRlQmFja3VwQ29kZXMsXG5cdGdldEJhY2t1cENvZGVzRnJvbURhdGFiYXNlLFxuXHRzYXZlQmFja3VwQ29kZXNUb0RhdGFiYXNlLFxuXHR2ZXJpZnlCYWNrdXBDb2RlXG59O1xuIl19
