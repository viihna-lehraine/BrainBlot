import path from 'path';
import { environmentVariables } from '../config/environmentConfig.mjs';
import { validateDependencies } from '../utils/validateDependencies.mjs';
import { processError } from '../utils/processError.mjs';
async function getSecrets({ logger, execSync, getDirectoryPath }) {
	try {
		validateDependencies(
			[
				{ name: 'logger', instance: logger },
				{ name: 'execSync', instance: execSync },
				{ name: 'getDirectoryPath', instance: getDirectoryPath }
			],
			logger
		);
		const secretsPath = path.join(
			getDirectoryPath(),
			'./config/secrets.json.gpg'
		);
		logger.info(`Resolved secrets path: ${secretsPath}`);
		const decryptedSecrets = execSync(
			`sops -d --output-type json ${secretsPath}`
		).toString();
		return JSON.parse(decryptedSecrets);
	} catch (error) {
		processError(error, logger);
		throw new Error(`
			Failed to get secrets: ${error instanceof Error ? error.message : String(error)}`);
	}
}
async function decryptKey({ logger, execSync }, encryptedFilePath) {
	try {
		validateDependencies(
			[
				{ name: 'logger', instance: logger },
				{ name: 'execSync', instance: execSync }
			],
			logger
		);
		const decryptedKey = execSync(
			`sops -d --output-type string ${encryptedFilePath}`
		).toString('utf-8');
		return decryptedKey;
	} catch (error) {
		if (error instanceof Error) {
			logger.error(`Command execution failed: ${error.message}`);
		} else {
			logger.error(`An unknown error occurred: ${String(error)}`);
		}
		processError(error, logger);
		throw new Error(
			`Failed to decrypt key: ${error instanceof Error ? error.message : String(error)}`
		);
	}
}
async function decryptDataFiles({ logger, execSync }) {
	try {
		validateDependencies(
			[
				{ name: 'logger', instance: logger },
				{ name: 'execSync', instance: execSync }
			],
			logger
		);
		const filePaths = [
			environmentVariables.serverDataFilePath1,
			environmentVariables.serverDataFilePath2,
			environmentVariables.serverDataFilePath3,
			environmentVariables.serverDataFilePath4
		];
		const decryptedFilesPromises = filePaths.map(
			async (filePath, index) => {
				if (filePath) {
					logger.info(`Decrypting file: ${filePath}`);
					return execSync(
						`sops -d --output-type json ${filePath}`
					).toString();
				} else {
					logger.warn(
						`SERVER_DATA_FILE_PATH_${index + 1} is not defined`
					);
					return '';
				}
			}
		);
		const decryptedFilesArray = await Promise.all(decryptedFilesPromises);
		const decryptedFiles = {};
		decryptedFilesArray.forEach((fileContent, index) => {
			if (fileContent) {
				decryptedFiles[`files${index + 1}`] = fileContent;
			}
		});
		return decryptedFiles;
	} catch (error) {
		processError(error, logger);
		throw new Error(
			`Unable to decrypt data files: ${error instanceof Error ? error.message : String(error)}`
		);
	}
}
async function getSSLKeys(dependencies) {
	try {
		validateDependencies(
			[
				{ name: 'logger', instance: dependencies.logger },
				{ name: 'execSync', instance: dependencies.execSync },
				{
					name: 'getDirectoryPath',
					instance: dependencies.getDirectoryPath
				}
			],
			dependencies.logger
		);
		const keyPath = path.join(
			dependencies.getDirectoryPath(),
			'./keys/ssl/guestbook_key.pem.gpg'
		);
		const certPath = path.join(
			dependencies.getDirectoryPath(),
			'./keys/ssl/guestbook_cert.pem.gpg'
		);
		const decryptedKey = await decryptKey(
			{ logger: dependencies.logger, execSync: dependencies.execSync },
			keyPath
		);
		const decryptedCert = await decryptKey(
			{ logger: dependencies.logger, execSync: dependencies.execSync },
			certPath
		);
		return {
			key: decryptedKey,
			cert: decryptedCert
		};
	} catch (error) {
		processError(error, dependencies.logger);
		throw new Error(
			`Unable to retrieve SSL keys: ${error instanceof Error ? error.message : String(error)}`
		);
	}
}
export default { getSecrets, decryptKey, decryptDataFiles, getSSLKeys };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29wcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zb3BzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUV4QixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNyRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUE0Q3JELEtBQUssVUFBVSxVQUFVLENBQUMsRUFDekIsTUFBTSxFQUNOLFFBQVEsRUFDUixnQkFBZ0IsRUFDRTtJQUNsQixJQUFJLENBQUM7UUFDSixvQkFBb0IsQ0FDbkI7WUFDQyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRTtZQUNwQyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRTtZQUN4QyxFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUU7U0FDeEQsRUFDRCxNQUFNLENBQ04sQ0FBQztRQUVGLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQzVCLGdCQUFnQixFQUFFLEVBQ2xCLDJCQUEyQixDQUMzQixDQUFDO1FBQ0YsTUFBTSxDQUFDLElBQUksQ0FBQywwQkFBMEIsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUNyRCxNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FDaEMsOEJBQThCLFdBQVcsRUFBRSxDQUMzQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDckMsQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDaEIsWUFBWSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztRQUM1QixNQUFNLElBQUksS0FBSyxDQUFDOzRCQUNVLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDckYsQ0FBQztBQUNGLENBQUM7QUFFRCxLQUFLLFVBQVUsVUFBVSxDQUN4QixFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQWlELEVBQ25FLGlCQUF5QjtJQUV6QixJQUFJLENBQUM7UUFDSixvQkFBb0IsQ0FDbkI7WUFDQyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRTtZQUNwQyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRTtTQUN4QyxFQUNELE1BQU0sQ0FDTixDQUFDO1FBRUYsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUM1QixnQ0FBZ0MsaUJBQWlCLEVBQUUsQ0FDbkQsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEIsT0FBTyxZQUFZLENBQUM7SUFDckIsQ0FBQztJQUFDLE9BQU8sS0FBYyxFQUFFLENBQUM7UUFDekIsSUFBSSxLQUFLLFlBQVksS0FBSyxFQUFFLENBQUM7WUFDNUIsTUFBTSxDQUFDLEtBQUssQ0FBQyw2QkFBNkIsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDNUQsQ0FBQzthQUFNLENBQUM7WUFDUCxNQUFNLENBQUMsS0FBSyxDQUFDLDhCQUE4QixNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzdELENBQUM7UUFDRCxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzVCLE1BQU0sSUFBSSxLQUFLLENBQ2QsMEJBQTBCLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUNsRixDQUFDO0lBQ0gsQ0FBQztBQUNGLENBQUM7QUFFRCxLQUFLLFVBQVUsZ0JBQWdCLENBQUMsRUFDL0IsTUFBTSxFQUNOLFFBQVEsRUFDdUM7SUFHL0MsSUFBSSxDQUFDO1FBQ0osb0JBQW9CLENBQ25CO1lBQ0MsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUU7WUFDcEMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUU7U0FDeEMsRUFDRCxNQUFNLENBQ04sQ0FBQztRQUVGLE1BQU0sU0FBUyxHQUE4QjtZQUM1QyxvQkFBb0IsQ0FBQyxtQkFBbUI7WUFDeEMsb0JBQW9CLENBQUMsbUJBQW1CO1lBQ3hDLG9CQUFvQixDQUFDLG1CQUFtQjtZQUN4QyxvQkFBb0IsQ0FBQyxtQkFBbUI7U0FDeEMsQ0FBQztRQUVGLE1BQU0sc0JBQXNCLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FDM0MsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUN6QixJQUFJLFFBQVEsRUFBRSxDQUFDO2dCQUNkLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLFFBQVEsRUFBRSxDQUFDLENBQUM7Z0JBQzVDLE9BQU8sUUFBUSxDQUNkLDhCQUE4QixRQUFRLEVBQUUsQ0FDeEMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNkLENBQUM7aUJBQU0sQ0FBQztnQkFDUCxNQUFNLENBQUMsSUFBSSxDQUNWLHlCQUF5QixLQUFLLEdBQUcsQ0FBQyxpQkFBaUIsQ0FDbkQsQ0FBQztnQkFDRixPQUFPLEVBQUUsQ0FBQztZQUNYLENBQUM7UUFDRixDQUFDLENBQ0QsQ0FBQztRQUVGLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFFdEUsTUFBTSxjQUFjLEdBQThCLEVBQUUsQ0FBQztRQUNyRCxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDbEQsSUFBSSxXQUFXLEVBQUUsQ0FBQztnQkFDakIsY0FBYyxDQUFDLFFBQVEsS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDO1lBQ25ELENBQUM7UUFDRixDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sY0FBYyxDQUFDO0lBQ3ZCLENBQUM7SUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2hCLFlBQVksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FDZCxpQ0FBaUMsS0FBSyxZQUFZLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQ3pGLENBQUM7SUFDSCxDQUFDO0FBQ0YsQ0FBQztBQUVELEtBQUssVUFBVSxVQUFVLENBQ3hCLFlBQThCO0lBRTlCLElBQUksQ0FBQztRQUNKLG9CQUFvQixDQUNuQjtZQUNDLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDLE1BQU0sRUFBRTtZQUNqRCxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFlBQVksQ0FBQyxRQUFRLEVBQUU7WUFDckQ7Z0JBQ0MsSUFBSSxFQUFFLGtCQUFrQjtnQkFDeEIsUUFBUSxFQUFFLFlBQVksQ0FBQyxnQkFBZ0I7YUFDdkM7U0FDRCxFQUNELFlBQVksQ0FBQyxNQUFNLENBQ25CLENBQUM7UUFFRixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUN4QixZQUFZLENBQUMsZ0JBQWdCLEVBQUUsRUFDL0Isa0NBQWtDLENBQ2xDLENBQUM7UUFFRixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUN6QixZQUFZLENBQUMsZ0JBQWdCLEVBQUUsRUFDL0IsbUNBQW1DLENBQ25DLENBQUM7UUFFRixNQUFNLFlBQVksR0FBRyxNQUFNLFVBQVUsQ0FDcEMsRUFBRSxNQUFNLEVBQUUsWUFBWSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDLFFBQVEsRUFBRSxFQUNoRSxPQUFPLENBQ1AsQ0FBQztRQUVGLE1BQU0sYUFBYSxHQUFHLE1BQU0sVUFBVSxDQUNyQyxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQ2hFLFFBQVEsQ0FDUixDQUFDO1FBRUYsT0FBTztZQUNOLEdBQUcsRUFBRSxZQUFZO1lBQ2pCLElBQUksRUFBRSxhQUFhO1NBQ25CLENBQUM7SUFDSCxDQUFDO0lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNoQixZQUFZLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6QyxNQUFNLElBQUksS0FBSyxDQUNkLGdDQUFnQyxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FDeEYsQ0FBQztJQUNILENBQUM7QUFDRixDQUFDO0FBRUQsZUFBZSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9jb25maWcvbG9nZ2VyJztcbmltcG9ydCB7IGVudmlyb25tZW50VmFyaWFibGVzIH0gZnJvbSAnLi4vY29uZmlnL2Vudmlyb25tZW50Q29uZmlnJztcbmltcG9ydCB7IHZhbGlkYXRlRGVwZW5kZW5jaWVzIH0gZnJvbSAnLi4vdXRpbHMvdmFsaWRhdGVEZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgcHJvY2Vzc0Vycm9yIH0gZnJvbSAnLi4vdXRpbHMvcHJvY2Vzc0Vycm9yJztcblxuaW50ZXJmYWNlIFNvcHNEZXBlbmRlbmNpZXMge1xuXHRsb2dnZXI6IExvZ2dlcjtcblx0ZXhlY1N5bmM6IHR5cGVvZiBleGVjU3luYztcblx0Z2V0RGlyZWN0b3J5UGF0aDogKCkgPT4gc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2VjcmV0cyB7XG5cdFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmdbXSB8IG51bWJlcltdIHwgYm9vbGVhbltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlY3JldHNNYXAgZXh0ZW5kcyBTZWNyZXRzIHtcblx0QVBQX1NTTF9LRVk6IHN0cmluZztcblx0QVBQX1NTTF9DRVJUOiBzdHJpbmc7XG5cdERCX1NTTF9LRVk6IHN0cmluZztcblx0REJfU1NMX0NFUlQ6IHN0cmluZztcblx0REJfTkFNRTogc3RyaW5nO1xuXHREQl9VU0VSOiBzdHJpbmc7XG5cdERCX1BBU1NXT1JEOiBzdHJpbmc7XG5cdERCX0hPU1Q6IHN0cmluZztcblx0REJfRElBTEVDVDogJ215c3FsJyB8ICdwb3N0Z3JlcycgfCAnc3FsaXRlJyB8ICdtYXJpYWRiJyB8ICdtc3NxbCc7XG5cdEVNQUlMXzJGQV9LRVk6IHN0cmluZztcblx0RU1BSUxfSE9TVDogc3RyaW5nO1xuXHRFTUFJTF9QT1JUOiBudW1iZXI7XG5cdEVNQUlMX1NFQ1VSRTogYm9vbGVhbjtcblx0RklET19BVVRIRU5USUNBVE9SX1JFUVVJUkVfUkVTSURFTlRfS0VZOiBib29sZWFuO1xuXHRGSURPX0FVVEhFTlRJQ0FUT1JfVVNFUl9WRVJJRklDQVRJT046XG5cdFx0fCAncmVxdWlyZWQnXG5cdFx0fCAncHJlZmVycmVkJ1xuXHRcdHwgJ2Rpc2NvdXJhZ2VkJztcblx0RklET19DSEFMTEVOR0VfU0laRTogbnVtYmVyO1xuXHRGSURPX0NSWVBUT19QQVJBTUVURVJTOiBudW1iZXJbXTtcblx0SldUX1NFQ1JFVDogc3RyaW5nO1xuXHRQRVBQRVI6IHN0cmluZztcblx0UlBfSUQ6IHN0cmluZztcblx0UlBfTkFNRTogc3RyaW5nO1xuXHRSUF9JQ09OOiBzdHJpbmc7XG5cdFNFU1NJT05fU0VDUkVUOiBzdHJpbmc7XG5cdFNNVFBfVE9LRU46IHN0cmluZztcblx0WVVCSUNPX0NMSUVOVF9JRDogbnVtYmVyO1xuXHRZVUJJQ09fU0VDUkVUX0tFWTogc3RyaW5nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRTZWNyZXRzKHtcblx0bG9nZ2VyLFxuXHRleGVjU3luYyxcblx0Z2V0RGlyZWN0b3J5UGF0aFxufTogU29wc0RlcGVuZGVuY2llcyk6IFByb21pc2U8U2VjcmV0c01hcD4ge1xuXHR0cnkge1xuXHRcdHZhbGlkYXRlRGVwZW5kZW5jaWVzKFxuXHRcdFx0W1xuXHRcdFx0XHR7IG5hbWU6ICdsb2dnZXInLCBpbnN0YW5jZTogbG9nZ2VyIH0sXG5cdFx0XHRcdHsgbmFtZTogJ2V4ZWNTeW5jJywgaW5zdGFuY2U6IGV4ZWNTeW5jIH0sXG5cdFx0XHRcdHsgbmFtZTogJ2dldERpcmVjdG9yeVBhdGgnLCBpbnN0YW5jZTogZ2V0RGlyZWN0b3J5UGF0aCB9XG5cdFx0XHRdLFxuXHRcdFx0bG9nZ2VyXG5cdFx0KTtcblxuXHRcdGNvbnN0IHNlY3JldHNQYXRoID0gcGF0aC5qb2luKFxuXHRcdFx0Z2V0RGlyZWN0b3J5UGF0aCgpLFxuXHRcdFx0Jy4vY29uZmlnL3NlY3JldHMuanNvbi5ncGcnXG5cdFx0KTtcblx0XHRsb2dnZXIuaW5mbyhgUmVzb2x2ZWQgc2VjcmV0cyBwYXRoOiAke3NlY3JldHNQYXRofWApO1xuXHRcdGNvbnN0IGRlY3J5cHRlZFNlY3JldHMgPSBleGVjU3luYyhcblx0XHRcdGBzb3BzIC1kIC0tb3V0cHV0LXR5cGUganNvbiAke3NlY3JldHNQYXRofWBcblx0XHQpLnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoZGVjcnlwdGVkU2VjcmV0cyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cHJvY2Vzc0Vycm9yKGVycm9yLCBsb2dnZXIpO1xuXHRcdHRocm93IG5ldyBFcnJvcihgXG5cdFx0XHRGYWlsZWQgdG8gZ2V0IHNlY3JldHM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRLZXkoXG5cdHsgbG9nZ2VyLCBleGVjU3luYyB9OiBQaWNrPFNvcHNEZXBlbmRlbmNpZXMsICdsb2dnZXInIHwgJ2V4ZWNTeW5jJz4sXG5cdGVuY3J5cHRlZEZpbGVQYXRoOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nPiB7XG5cdHRyeSB7XG5cdFx0dmFsaWRhdGVEZXBlbmRlbmNpZXMoXG5cdFx0XHRbXG5cdFx0XHRcdHsgbmFtZTogJ2xvZ2dlcicsIGluc3RhbmNlOiBsb2dnZXIgfSxcblx0XHRcdFx0eyBuYW1lOiAnZXhlY1N5bmMnLCBpbnN0YW5jZTogZXhlY1N5bmMgfVxuXHRcdFx0XSxcblx0XHRcdGxvZ2dlclxuXHRcdCk7XG5cblx0XHRjb25zdCBkZWNyeXB0ZWRLZXkgPSBleGVjU3luYyhcblx0XHRcdGBzb3BzIC1kIC0tb3V0cHV0LXR5cGUgc3RyaW5nICR7ZW5jcnlwdGVkRmlsZVBhdGh9YFxuXHRcdCkudG9TdHJpbmcoJ3V0Zi04Jyk7XG5cdFx0cmV0dXJuIGRlY3J5cHRlZEtleTtcblx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0bG9nZ2VyLmVycm9yKGBDb21tYW5kIGV4ZWN1dGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nZ2VyLmVycm9yKGBBbiB1bmtub3duIGVycm9yIG9jY3VycmVkOiAke1N0cmluZyhlcnJvcil9YCk7XG5cdFx0fVxuXHRcdHByb2Nlc3NFcnJvcihlcnJvciwgbG9nZ2VyKTtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRgRmFpbGVkIHRvIGRlY3J5cHQga2V5OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gXG5cdFx0KTtcblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0RGF0YUZpbGVzKHtcblx0bG9nZ2VyLFxuXHRleGVjU3luY1xufTogUGljazxTb3BzRGVwZW5kZW5jaWVzLCAnbG9nZ2VyJyB8ICdleGVjU3luYyc+KTogUHJvbWlzZTx7XG5cdFtrZXk6IHN0cmluZ106IHN0cmluZztcbn0+IHtcblx0dHJ5IHtcblx0XHR2YWxpZGF0ZURlcGVuZGVuY2llcyhcblx0XHRcdFtcblx0XHRcdFx0eyBuYW1lOiAnbG9nZ2VyJywgaW5zdGFuY2U6IGxvZ2dlciB9LFxuXHRcdFx0XHR7IG5hbWU6ICdleGVjU3luYycsIGluc3RhbmNlOiBleGVjU3luYyB9XG5cdFx0XHRdLFxuXHRcdFx0bG9nZ2VyXG5cdFx0KTtcblxuXHRcdGNvbnN0IGZpbGVQYXRoczogQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkPiA9IFtcblx0XHRcdGVudmlyb25tZW50VmFyaWFibGVzLnNlcnZlckRhdGFGaWxlUGF0aDEsXG5cdFx0XHRlbnZpcm9ubWVudFZhcmlhYmxlcy5zZXJ2ZXJEYXRhRmlsZVBhdGgyLFxuXHRcdFx0ZW52aXJvbm1lbnRWYXJpYWJsZXMuc2VydmVyRGF0YUZpbGVQYXRoMyxcblx0XHRcdGVudmlyb25tZW50VmFyaWFibGVzLnNlcnZlckRhdGFGaWxlUGF0aDRcblx0XHRdO1xuXG5cdFx0Y29uc3QgZGVjcnlwdGVkRmlsZXNQcm9taXNlcyA9IGZpbGVQYXRocy5tYXAoXG5cdFx0XHRhc3luYyAoZmlsZVBhdGgsIGluZGV4KSA9PiB7XG5cdFx0XHRcdGlmIChmaWxlUGF0aCkge1xuXHRcdFx0XHRcdGxvZ2dlci5pbmZvKGBEZWNyeXB0aW5nIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XG5cdFx0XHRcdFx0cmV0dXJuIGV4ZWNTeW5jKFxuXHRcdFx0XHRcdFx0YHNvcHMgLWQgLS1vdXRwdXQtdHlwZSBqc29uICR7ZmlsZVBhdGh9YFxuXHRcdFx0XHRcdCkudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2dnZXIud2Fybihcblx0XHRcdFx0XHRcdGBTRVJWRVJfREFUQV9GSUxFX1BBVEhfJHtpbmRleCArIDF9IGlzIG5vdCBkZWZpbmVkYFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGNvbnN0IGRlY3J5cHRlZEZpbGVzQXJyYXkgPSBhd2FpdCBQcm9taXNlLmFsbChkZWNyeXB0ZWRGaWxlc1Byb21pc2VzKTtcblxuXHRcdGNvbnN0IGRlY3J5cHRlZEZpbGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG5cdFx0ZGVjcnlwdGVkRmlsZXNBcnJheS5mb3JFYWNoKChmaWxlQ29udGVudCwgaW5kZXgpID0+IHtcblx0XHRcdGlmIChmaWxlQ29udGVudCkge1xuXHRcdFx0XHRkZWNyeXB0ZWRGaWxlc1tgZmlsZXMke2luZGV4ICsgMX1gXSA9IGZpbGVDb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGRlY3J5cHRlZEZpbGVzO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHByb2Nlc3NFcnJvcihlcnJvciwgbG9nZ2VyKTtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRgVW5hYmxlIHRvIGRlY3J5cHQgZGF0YSBmaWxlczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YFxuXHRcdCk7XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U1NMS2V5cyhcblx0ZGVwZW5kZW5jaWVzOiBTb3BzRGVwZW5kZW5jaWVzXG4pOiBQcm9taXNlPHsga2V5OiBzdHJpbmc7IGNlcnQ6IHN0cmluZyB9PiB7XG5cdHRyeSB7XG5cdFx0dmFsaWRhdGVEZXBlbmRlbmNpZXMoXG5cdFx0XHRbXG5cdFx0XHRcdHsgbmFtZTogJ2xvZ2dlcicsIGluc3RhbmNlOiBkZXBlbmRlbmNpZXMubG9nZ2VyIH0sXG5cdFx0XHRcdHsgbmFtZTogJ2V4ZWNTeW5jJywgaW5zdGFuY2U6IGRlcGVuZGVuY2llcy5leGVjU3luYyB9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogJ2dldERpcmVjdG9yeVBhdGgnLFxuXHRcdFx0XHRcdGluc3RhbmNlOiBkZXBlbmRlbmNpZXMuZ2V0RGlyZWN0b3J5UGF0aFxuXHRcdFx0XHR9XG5cdFx0XHRdLFxuXHRcdFx0ZGVwZW5kZW5jaWVzLmxvZ2dlclxuXHRcdCk7XG5cblx0XHRjb25zdCBrZXlQYXRoID0gcGF0aC5qb2luKFxuXHRcdFx0ZGVwZW5kZW5jaWVzLmdldERpcmVjdG9yeVBhdGgoKSxcblx0XHRcdCcuL2tleXMvc3NsL2d1ZXN0Ym9va19rZXkucGVtLmdwZydcblx0XHQpO1xuXG5cdFx0Y29uc3QgY2VydFBhdGggPSBwYXRoLmpvaW4oXG5cdFx0XHRkZXBlbmRlbmNpZXMuZ2V0RGlyZWN0b3J5UGF0aCgpLFxuXHRcdFx0Jy4va2V5cy9zc2wvZ3Vlc3Rib29rX2NlcnQucGVtLmdwZydcblx0XHQpO1xuXG5cdFx0Y29uc3QgZGVjcnlwdGVkS2V5ID0gYXdhaXQgZGVjcnlwdEtleShcblx0XHRcdHsgbG9nZ2VyOiBkZXBlbmRlbmNpZXMubG9nZ2VyLCBleGVjU3luYzogZGVwZW5kZW5jaWVzLmV4ZWNTeW5jIH0sXG5cdFx0XHRrZXlQYXRoXG5cdFx0KTtcblxuXHRcdGNvbnN0IGRlY3J5cHRlZENlcnQgPSBhd2FpdCBkZWNyeXB0S2V5KFxuXHRcdFx0eyBsb2dnZXI6IGRlcGVuZGVuY2llcy5sb2dnZXIsIGV4ZWNTeW5jOiBkZXBlbmRlbmNpZXMuZXhlY1N5bmMgfSxcblx0XHRcdGNlcnRQYXRoXG5cdFx0KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRrZXk6IGRlY3J5cHRlZEtleSxcblx0XHRcdGNlcnQ6IGRlY3J5cHRlZENlcnRcblx0XHR9O1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHByb2Nlc3NFcnJvcihlcnJvciwgZGVwZW5kZW5jaWVzLmxvZ2dlcik7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0YFVuYWJsZSB0byByZXRyaWV2ZSBTU0wga2V5czogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YFxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBnZXRTZWNyZXRzLCBkZWNyeXB0S2V5LCBkZWNyeXB0RGF0YUZpbGVzLCBnZXRTU0xLZXlzIH07XG4iXX0=
