import path from 'path';
import { environmentVariables } from '../config/environmentConfig.mjs';
import { processError } from '../utils/processError.mjs';
import { validateDependencies } from '../utils/validateDependencies.mjs';
async function getSecrets({ logger, execSync, getDirectoryPath }) {
	try {
		validateDependencies(
			[
				{ name: 'logger', instance: logger },
				{ name: 'execSync', instance: execSync },
				{ name: 'getDirectoryPath', instance: getDirectoryPath }
			],
			logger
		);
		const secretsPath = path.join(
			getDirectoryPath(),
			'./config/secrets.json.gpg'
		);
		logger.info(`Resolved secrets path: ${secretsPath}`);
		const decryptedSecrets = execSync(
			`sops -d --output-type json ${secretsPath}`
		).toString();
		return JSON.parse(decryptedSecrets);
	} catch (error) {
		processError(error, logger);
		throw new Error(`
			Failed to get secrets: ${error instanceof Error ? error.message : String(error)}`);
	}
}
async function decryptKey({ logger, execSync }, encryptedFilePath) {
	try {
		validateDependencies(
			[
				{ name: 'logger', instance: logger },
				{ name: 'execSync', instance: execSync }
			],
			logger
		);
		const decryptedKey = execSync(
			`sops -d --output-type string ${encryptedFilePath}`
		).toString('utf-8');
		return decryptedKey;
	} catch (error) {
		if (error instanceof Error) {
			logger.error(`Command execution failed: ${error.message}`);
		} else {
			logger.error(`An unknown error occurred: ${String(error)}`);
		}
		processError(error, logger);
		throw new Error(
			`Failed to decrypt key: ${error instanceof Error ? error.message : String(error)}`
		);
	}
}
async function decryptDataFiles({ logger, execSync }) {
	try {
		validateDependencies(
			[
				{ name: 'logger', instance: logger },
				{ name: 'execSync', instance: execSync }
			],
			logger
		);
		const filePaths = [
			environmentVariables.serverDataFilePath1,
			environmentVariables.serverDataFilePath2,
			environmentVariables.serverDataFilePath3,
			environmentVariables.serverDataFilePath4
		];
		const decryptedFilesPromises = filePaths.map(
			async (filePath, index) => {
				if (filePath) {
					logger.info(`Decrypting file: ${filePath}`);
					return execSync(
						`sops -d --output-type json ${filePath}`
					).toString();
				} else {
					logger.warn(
						`SERVER_DATA_FILE_PATH_${index + 1} is not defined`
					);
					return '';
				}
			}
		);
		const decryptedFilesArray = await Promise.all(decryptedFilesPromises);
		const decryptedFiles = {};
		decryptedFilesArray.forEach((fileContent, index) => {
			if (fileContent) {
				decryptedFiles[`files${index + 1}`] = fileContent;
			}
		});
		return decryptedFiles;
	} catch (error) {
		processError(error, logger);
		throw new Error(
			`Unable to decrypt data files: ${error instanceof Error ? error.message : String(error)}`
		);
	}
}
async function getSSLKeys(dependencies) {
	try {
		validateDependencies(
			[
				{ name: 'logger', instance: dependencies.logger },
				{ name: 'execSync', instance: dependencies.execSync },
				{
					name: 'getDirectoryPath',
					instance: dependencies.getDirectoryPath
				}
			],
			dependencies.logger
		);
		const keyPath = path.join(
			dependencies.getDirectoryPath(),
			'./keys/ssl/guestbook_key.pem.gpg'
		);
		const certPath = path.join(
			dependencies.getDirectoryPath(),
			'./keys/ssl/guestbook_cert.pem.gpg'
		);
		const decryptedKey = await decryptKey(
			{ logger: dependencies.logger, execSync: dependencies.execSync },
			keyPath
		);
		const decryptedCert = await decryptKey(
			{ logger: dependencies.logger, execSync: dependencies.execSync },
			certPath
		);
		return {
			key: decryptedKey,
			cert: decryptedCert
		};
	} catch (error) {
		processError(error, dependencies.logger);
		throw new Error(
			`Unable to retrieve SSL keys: ${error instanceof Error ? error.message : String(error)}`
		);
	}
}
export default { getSecrets, decryptKey, decryptDataFiles, getSSLKeys };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29wcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zb3BzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUVuRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDckQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUEwQ3JFLEtBQUssVUFBVSxVQUFVLENBQUMsRUFDekIsTUFBTSxFQUNOLFFBQVEsRUFDUixnQkFBZ0IsRUFDRTtJQUNsQixJQUFJLENBQUM7UUFDSixvQkFBb0IsQ0FDbkI7WUFDQyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRTtZQUNwQyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRTtZQUN4QyxFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUU7U0FDeEQsRUFDRCxNQUFNLENBQ04sQ0FBQztRQUVGLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQzVCLGdCQUFnQixFQUFFLEVBQ2xCLDJCQUEyQixDQUMzQixDQUFDO1FBQ0YsTUFBTSxDQUFDLElBQUksQ0FBQywwQkFBMEIsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUNyRCxNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FDaEMsOEJBQThCLFdBQVcsRUFBRSxDQUMzQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDckMsQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDaEIsWUFBWSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztRQUM1QixNQUFNLElBQUksS0FB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QUVGLE1BQU0sYUFBYSxHQUFHLE1BQU0sVUFBVSxDQUNyQyxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQ2hFLFFBQVEsQ0FDUixDQUFDO1FBRUYsT0FBTztZQUNOLEdBQUcsRUFBRSxZQUFZO1lBQ2pCLElBQUksRUFBRSxhQUFhO1NBQ25CLENBQUM7SUFDSCxDQUFDO0lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNoQixZQUFZLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6QyxNQUFNLElBQUksS0FBSyxDQUNkLGdDQUFnQyxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FDeEYsQ0FBQztJQUNILENBQUM7QUFDRixDQUFDO0FBRUQsZUFBZSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBlbnZpcm9ubWVudFZhcmlhYmxlcyB9IGZyb20gJy4uL2NvbmZpZy9lbnZpcm9ubWVudENvbmZpZyc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9jb25maWcvbG9nZ2VyJztcbmltcG9ydCB7IHByb2Nlc3NFcnJvciB9IGZyb20gJy4uL3V0aWxzL3Byb2Nlc3NFcnJvcic7XG5pbXBvcnQgeyB2YWxpZGF0ZURlcGVuZGVuY2llcyB9IGZyb20gJy4uL3V0aWxzL3ZhbGlkYXRlRGVwZW5kZW5jaWVzJztcblxuaW50ZXJmYWNlIFNvcHNEZXBlbmRlbmNpZXMge1xuXHRsb2dnZXI6IExvZ2dlcjtcblx0ZXhlY1N5bmM6IHR5cGVvZiBleGVjU3luYztcblx0Z2V0RGlyZWN0b3J5UGF0aDogKCkgPT4gc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2VjcmV0cyB7XG5cdFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmdbXSB8IG51bWJlcltdIHwgYm9vbGVhbltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlY3JldHNNYXAgZXh0ZW5kcyBTZWNyZXRzIHtcblx0QVBQX1NTTF9LRVk6IHN0cmluZztcblx0QVBQX1NTTF9DRVJUOiBzdHJpbmc7XG5cdERCX05BTUU6IHN0cmluZztcblx0REJfVVNFUjogc3RyaW5nO1xuXHREQl9QQVNTV09SRDogc3RyaW5nO1xuXHREQl9IT1NUOiBzdHJpbmc7XG5cdERCX0RJQUxFQ1Q6ICdteXNxbCcgfCAncG9zdGdyZXMnIHwgJ3NxbGl0ZScgfCAnbWFyaWFkYicgfCAnbXNzcWwnO1xuXHRFTUFJTF8yRkFfS0VZOiBzdHJpbmc7XG5cdEVNQUlMX0hPU1Q6IHN0cmluZztcblx0RU1BSUxfUE9SVDogbnVtYmVyO1xuXHRFTUFJTF9TRUNVUkU6IGJvb2xlYW47XG5cdEZJRE9fQVVUSEVOVElDQVRPUl9SRVFVSVJFX1JFU0lERU5UX0tFWTogYm9vbGVhbjtcblx0RklET19BVVRIRU5USUNBVE9SX1VTRVJfVkVSSUZJQ0FUSU9OOlxuXHRcdHwgJ3JlcXVpcmVkJ1xuXHRcdHwgJ3ByZWZlcnJlZCdcblx0XHR8ICdkaXNjb3VyYWdlZCc7XG5cdEZJRE9fQ0hBTExFTkdFX1NJWkU6IG51bWJlcjtcblx0RklET19DUllQVE9fUEFSQU1FVEVSUzogbnVtYmVyW107XG5cdEpXVF9TRUNSRVQ6IHN0cmluZztcblx0UEVQUEVSOiBzdHJpbmc7XG5cdFJQX0lEOiBzdHJpbmc7XG5cdFJQX05BTUU6IHN0cmluZztcblx0UlBfSUNPTjogc3RyaW5nO1xuXHRTRVNTSU9OX1NFQ1JFVDogc3RyaW5nO1xuXHRTTVRQX1RPS0VOOiBzdHJpbmc7XG5cdFlVQklDT19DTElFTlRfSUQ6IG51bWJlcjtcblx0WVVCSUNPX1NFQ1JFVF9LRVk6IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VjcmV0cyh7XG5cdGxvZ2dlcixcblx0ZXhlY1N5bmMsXG5cdGdldERpcmVjdG9yeVBhdGhcbn06IFNvcHNEZXBlbmRlbmNpZXMpOiBQcm9taXNlPFNlY3JldHNNYXA+IHtcblx0dHJ5IHtcblx0XHR2YWxpZGF0ZURlcGVuZGVuY2llcyhcblx0XHRcdFtcblx0XHRcdFx0eyBuYW1lOiAnbG9nZ2VyJywgaW5zdGFuY2U6IGxvZ2dlciB9LFxuXHRcdFx0XHR7IG5hbWU6ICdleGVjU3luYycsIGluc3RhbmNlOiBleGVjU3luYyB9LFxuXHRcdFx0XHR7IG5hbWU6ICdnZXREaXJlY3RvcnlQYXRoJywgaW5zdGFuY2U6IGdldERpcmVjdG9yeVBhdGggfVxuXHRcdFx0XSxcblx0XHRcdGxvZ2dlclxuXHRcdCk7XG5cblx0XHRjb25zdCBzZWNyZXRzUGF0aCA9IHBhdGguam9pbihcblx0XHRcdGdldERpcmVjdG9yeVBhdGgoKSxcblx0XHRcdCcuL2NvbmZpZy9zZWNyZXRzLmpzb24uZ3BnJ1xuXHRcdCk7XG5cdFx0bG9nZ2VyLmluZm8oYFJlc29sdmVkIHNlY3JldHMgcGF0aDogJHtzZWNyZXRzUGF0aH1gKTtcblx0XHRjb25zdCBkZWNyeXB0ZWRTZWNyZXRzID0gZXhlY1N5bmMoXG5cdFx0XHRgc29wcyAtZCAtLW91dHB1dC10eXBlIGpzb24gJHtzZWNyZXRzUGF0aH1gXG5cdFx0KS50b1N0cmluZygpO1xuXHRcdHJldHVybiBKU09OLnBhcnNlKGRlY3J5cHRlZFNlY3JldHMpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHByb2Nlc3NFcnJvcihlcnJvciwgbG9nZ2VyKTtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFxuXHRcdFx0RmFpbGVkIHRvIGdldCBzZWNyZXRzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0S2V5KFxuXHR7IGxvZ2dlciwgZXhlY1N5bmMgfTogUGljazxTb3BzRGVwZW5kZW5jaWVzLCAnbG9nZ2VyJyB8ICdleGVjU3luYyc+LFxuXHRlbmNyeXB0ZWRGaWxlUGF0aDogc3RyaW5nXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuXHR0cnkge1xuXHRcdHZhbGlkYXRlRGVwZW5kZW5jaWVzKFxuXHRcdFx0W1xuXHRcdFx0XHR7IG5hbWU6ICdsb2dnZXInLCBpbnN0YW5jZTogbG9nZ2VyIH0sXG5cdFx0XHRcdHsgbmFtZTogJ2V4ZWNTeW5jJywgaW5zdGFuY2U6IGV4ZWNTeW5jIH1cblx0XHRcdF0sXG5cdFx0XHRsb2dnZXJcblx0XHQpO1xuXG5cdFx0Y29uc3QgZGVjcnlwdGVkS2V5ID0gZXhlY1N5bmMoXG5cdFx0XHRgc29wcyAtZCAtLW91dHB1dC10eXBlIHN0cmluZyAke2VuY3J5cHRlZEZpbGVQYXRofWBcblx0XHQpLnRvU3RyaW5nKCd1dGYtOCcpO1xuXHRcdHJldHVybiBkZWNyeXB0ZWRLZXk7XG5cdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdGxvZ2dlci5lcnJvcihgQ29tbWFuZCBleGVjdXRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZ2dlci5lcnJvcihgQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZDogJHtTdHJpbmcoZXJyb3IpfWApO1xuXHRcdH1cblx0XHRwcm9jZXNzRXJyb3IoZXJyb3IsIGxvZ2dlcik7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0YEZhaWxlZCB0byBkZWNyeXB0IGtleTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YFxuXHRcdCk7XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdERhdGFGaWxlcyh7XG5cdGxvZ2dlcixcblx0ZXhlY1N5bmNcbn06IFBpY2s8U29wc0RlcGVuZGVuY2llcywgJ2xvZ2dlcicgfCAnZXhlY1N5bmMnPik6IFByb21pc2U8e1xuXHRba2V5OiBzdHJpbmddOiBzdHJpbmc7XG59PiB7XG5cdHRyeSB7XG5cdFx0dmFsaWRhdGVEZXBlbmRlbmNpZXMoXG5cdFx0XHRbXG5cdFx0XHRcdHsgbmFtZTogJ2xvZ2dlcicsIGluc3RhbmNlOiBsb2dnZXIgfSxcblx0XHRcdFx0eyBuYW1lOiAnZXhlY1N5bmMnLCBpbnN0YW5jZTogZXhlY1N5bmMgfVxuXHRcdFx0XSxcblx0XHRcdGxvZ2dlclxuXHRcdCk7XG5cblx0XHRjb25zdCBmaWxlUGF0aHM6IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD4gPSBbXG5cdFx0XHRlbnZpcm9ubWVudFZhcmlhYmxlcy5zZXJ2ZXJEYXRhRmlsZVBhdGgxLFxuXHRcdFx0ZW52aXJvbm1lbnRWYXJpYWJsZXMuc2VydmVyRGF0YUZpbGVQYXRoMixcblx0XHRcdGVudmlyb25tZW50VmFyaWFibGVzLnNlcnZlckRhdGFGaWxlUGF0aDMsXG5cdFx0XHRlbnZpcm9ubWVudFZhcmlhYmxlcy5zZXJ2ZXJEYXRhRmlsZVBhdGg0XG5cdFx0XTtcblxuXHRcdGNvbnN0IGRlY3J5cHRlZEZpbGVzUHJvbWlzZXMgPSBmaWxlUGF0aHMubWFwKFxuXHRcdFx0YXN5bmMgKGZpbGVQYXRoLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRpZiAoZmlsZVBhdGgpIHtcblx0XHRcdFx0XHRsb2dnZXIuaW5mbyhgRGVjcnlwdGluZyBmaWxlOiAke2ZpbGVQYXRofWApO1xuXHRcdFx0XHRcdHJldHVybiBleGVjU3luYyhcblx0XHRcdFx0XHRcdGBzb3BzIC1kIC0tb3V0cHV0LXR5cGUganNvbiAke2ZpbGVQYXRofWBcblx0XHRcdFx0XHQpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9nZ2VyLndhcm4oXG5cdFx0XHRcdFx0XHRgU0VSVkVSX0RBVEFfRklMRV9QQVRIXyR7aW5kZXggKyAxfSBpcyBub3QgZGVmaW5lZGBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRjb25zdCBkZWNyeXB0ZWRGaWxlc0FycmF5ID0gYXdhaXQgUHJvbWlzZS5hbGwoZGVjcnlwdGVkRmlsZXNQcm9taXNlcyk7XG5cblx0XHRjb25zdCBkZWNyeXB0ZWRGaWxlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXHRcdGRlY3J5cHRlZEZpbGVzQXJyYXkuZm9yRWFjaCgoZmlsZUNvbnRlbnQsIGluZGV4KSA9PiB7XG5cdFx0XHRpZiAoZmlsZUNvbnRlbnQpIHtcblx0XHRcdFx0ZGVjcnlwdGVkRmlsZXNbYGZpbGVzJHtpbmRleCArIDF9YF0gPSBmaWxlQ29udGVudDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkZWNyeXB0ZWRGaWxlcztcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRwcm9jZXNzRXJyb3IoZXJyb3IsIGxvZ2dlcik7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0YFVuYWJsZSB0byBkZWNyeXB0IGRhdGEgZmlsZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWBcblx0XHQpO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFNTTEtleXMoXG5cdGRlcGVuZGVuY2llczogU29wc0RlcGVuZGVuY2llc1xuKTogUHJvbWlzZTx7IGtleTogc3RyaW5nOyBjZXJ0OiBzdHJpbmcgfT4ge1xuXHR0cnkge1xuXHRcdHZhbGlkYXRlRGVwZW5kZW5jaWVzKFxuXHRcdFx0W1xuXHRcdFx0XHR7IG5hbWU6ICdsb2dnZXInLCBpbnN0YW5jZTogZGVwZW5kZW5jaWVzLmxvZ2dlciB9LFxuXHRcdFx0XHR7IG5hbWU6ICdleGVjU3luYycsIGluc3RhbmNlOiBkZXBlbmRlbmNpZXMuZXhlY1N5bmMgfSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6ICdnZXREaXJlY3RvcnlQYXRoJyxcblx0XHRcdFx0XHRpbnN0YW5jZTogZGVwZW5kZW5jaWVzLmdldERpcmVjdG9yeVBhdGhcblx0XHRcdFx0fVxuXHRcdFx0XSxcblx0XHRcdGRlcGVuZGVuY2llcy5sb2dnZXJcblx0XHQpO1xuXG5cdFx0Y29uc3Qga2V5UGF0aCA9IHBhdGguam9pbihcblx0XHRcdGRlcGVuZGVuY2llcy5nZXREaXJlY3RvcnlQYXRoKCksXG5cdFx0XHQnLi9rZXlzL3NzbC9ndWVzdGJvb2tfa2V5LnBlbS5ncGcnXG5cdFx0KTtcblxuXHRcdGNvbnN0IGNlcnRQYXRoID0gcGF0aC5qb2luKFxuXHRcdFx0ZGVwZW5kZW5jaWVzLmdldERpcmVjdG9yeVBhdGgoKSxcblx0XHRcdCcuL2tleXMvc3NsL2d1ZXN0Ym9va19jZXJ0LnBlbS5ncGcnXG5cdFx0KTtcblxuXHRcdGNvbnN0IGRlY3J5cHRlZEtleSA9IGF3YWl0IGRlY3J5cHRLZXkoXG5cdFx0XHR7IGxvZ2dlcjogZGVwZW5kZW5jaWVzLmxvZ2dlciwgZXhlY1N5bmM6IGRlcGVuZGVuY2llcy5leGVjU3luYyB9LFxuXHRcdFx0a2V5UGF0aFxuXHRcdCk7XG5cblx0XHRjb25zdCBkZWNyeXB0ZWRDZXJ0ID0gYXdhaXQgZGVjcnlwdEtleShcblx0XHRcdHsgbG9nZ2VyOiBkZXBlbmRlbmNpZXMubG9nZ2VyLCBleGVjU3luYzogZGVwZW5kZW5jaWVzLmV4ZWNTeW5jIH0sXG5cdFx0XHRjZXJ0UGF0aFxuXHRcdCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0a2V5OiBkZWNyeXB0ZWRLZXksXG5cdFx0XHRjZXJ0OiBkZWNyeXB0ZWRDZXJ0XG5cdFx0fTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRwcm9jZXNzRXJyb3IoZXJyb3IsIGRlcGVuZGVuY2llcy5sb2dnZXIpO1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGBVbmFibGUgdG8gcmV0cmlldmUgU1NMIGtleXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWBcblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgZ2V0U2VjcmV0cywgZGVjcnlwdEtleSwgZGVjcnlwdERhdGFGaWxlcywgZ2V0U1NMS2V5cyB9O1xuIl19
